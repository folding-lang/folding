// Generated from Folding.g4 by ANTLR 4.13.1
package foldingx.parser

import com.strumenta.kotlinmultiplatform.scoped
import org.antlr.v4.kotlinruntime.*
import org.antlr.v4.kotlinruntime.atn.*
import org.antlr.v4.kotlinruntime.atn.ATN.Companion.INVALID_ALT_NUMBER
import org.antlr.v4.kotlinruntime.dfa.*
import org.antlr.v4.kotlinruntime.misc.*
import org.antlr.v4.kotlinruntime.tree.*

@Suppress("FunctionName", "LocalVariableName", "ConvertSecondaryConstructorToPrimary")
public open class FoldingParser(input: TokenStream) : Parser(input) {
    override val grammarFileName: String =
        "Folding.g4"

    override val tokenNames: Array<String?> =
        FoldingParser.tokenNames

    override val ruleNames: Array<String> =
        FoldingParser.ruleNames

    override val atn: ATN =
        ATN

    override val vocabulary: Vocabulary =
        VOCABULARY

    public enum class Tokens(public val id: Int) {
        EOF(-1),
        WS(1),
        COMMENT(2),
        LINE_COMMENT(3),
        ABSTRACT(4),
        ANNOTATION(5),
        CLASS(6),
        DO(7),
        FOREIGN(8),
        NAMESPACE(9),
        INTERNAL(10),
        IMPORT(11),
        IMPL(12),
        INHERIT(13),
        RETURN(14),
        MUTABLE(15),
        INTERFACE(16),
        DATA(17),
        INVERSE(18),
        EXPECT(19),
        IF(20),
        ELSE(21),
        NEW(22),
        LET(23),
        TYPEALIAS(24),
        WHERE(25),
        FROM(26),
        IS(27),
        GET(28),
        SET(29),
        REMAIN(30),
        MATCH(31),
        INT(32),
        LONG(33),
        DOUBLE(34),
        FLOAT(35),
        BYTE(36),
        CHAR(37),
        STRING(38),
        BOOLEAN(39),
        UNIT(40),
        NULLKEYWORD(41),
        TRUE(42),
        FALSE(43),
        THIS(44),
        PIPE(45),
        ASSGIN(46),
        ELLIPSIS(47),
        DOT(48),
        LPAREN(49),
        RPAREN(50),
        LSQUARE(51),
        RSQUARE(52),
        LBRACE(53),
        RBRACE(54),
        ARROW(55),
        ARROWQM(56),
        TILDE(57),
        As(58),
        COLON(59),
        DOUBLECOLON(60),
        TRIPLECOLON(61),
        COLONSHARP(62),
        QUOTE(63),
        COLONQUOTE(64),
        SHARP(65),
        QM(66),
        EM(67),
        ID(68),
        OPID(69),
        Integer(70),
        Double(71),
        String(72),
        RawString(73)
    }

    public enum class Rules(public val id: Int) {
        RULE_file(0),
        RULE_fileCompo(1),
        RULE_importEx(2),
        RULE_importBody(3),
        RULE_importCompo(4),
        RULE_importDefAlias(5),
        RULE_importClassAlias(6),
        RULE_importType(7),
        RULE_importPath(8),
        RULE_importNest(9),
        RULE_packagePiece(10),
        RULE_package_(11),
        RULE_namespace(12),
        RULE_doBlock(13),
        RULE_compo(14),
        RULE_remainLet_binding(15),
        RULE_returning(16),
        RULE_fieldAssign(17),
        RULE_class_(18),
        RULE_constructor_(19),
        RULE_constructorSelf(20),
        RULE_defInInterface(21),
        RULE_fieldInInterface(22),
        RULE_inherit(23),
        RULE_impl(24),
        RULE_implBody(25),
        RULE_typeParam(26),
        RULE_typeParamCompo(27),
        RULE_definition(28),
        RULE_defaultValue(29),
        RULE_boolean(30),
        RULE_value(31),
        RULE_reference(32),
        RULE_typeCasting(33),
        RULE_if_else(34),
        RULE_let_binding(35),
        RULE_patternMatch(36),
        RULE_patternMatchCompo(37),
        RULE_tupleEx(38),
        RULE_paramEx(39),
        RULE_parameter(40),
        RULE_argEx(41),
        RULE_argValue(42),
        RULE_invoking(43),
        RULE_commonOpIdentifier(44),
        RULE_commonIdentifier(45),
        RULE_opIdWrap(46),
        RULE_aopIdWrap(47),
        RULE_commonClassIdentifier(48),
        RULE_field(49),
        RULE_fieldNotInit(50),
        RULE_fieldSetted(51),
        RULE_foreignField(52),
        RULE_def(53),
        RULE_justDef(54),
        RULE_foreignDef(55),
        RULE_inverseDefining(56),
        RULE_inverseDefCompo(57),
        RULE_inverseDefGateCompo(58),
        RULE_lambda(59),
        RULE_typeEx(60),
        RULE_typeExSingle(61),
        RULE_typeArgEx(62),
        RULE_primitiveType(63),
        RULE_typeExParamEx(64),
        RULE_typeExFunc(65),
        RULE_typeExCovariant(66),
        RULE_typeExContravariant(67),
        RULE_typeExWildcard(68),
        RULE_foreignBody(69),
        RULE_foreignElement(70),
        RULE_foreignPlatform(71),
        RULE_typeAlias(72),
        RULE_foreignTypeExpectitive(73),
        RULE_annotationDef(74),
        RULE_annotation(75),
        RULE_annotationBlock(76)
    }

    public companion object {
        private val decisionToDFA: Array<DFA>
        private val sharedContextCache = PredictionContextCache()
        private val ruleNames =
            arrayOf("file", "fileCompo", "importEx", "importBody", "importCompo", 
                    "importDefAlias", "importClassAlias", "importType", 
                    "importPath", "importNest", "packagePiece", "package_", 
                    "namespace", "doBlock", "compo", "remainLet_binding", 
                    "returning", "fieldAssign", "class_", "constructor_", 
                    "constructorSelf", "defInInterface", "fieldInInterface", 
                    "inherit", "impl", "implBody", "typeParam", "typeParamCompo", 
                    "definition", "defaultValue", "boolean", "value", "reference", 
                    "typeCasting", "if_else", "let_binding", "patternMatch", 
                    "patternMatchCompo", "tupleEx", "paramEx", "parameter", 
                    "argEx", "argValue", "invoking", "commonOpIdentifier", 
                    "commonIdentifier", "opIdWrap", "aopIdWrap", "commonClassIdentifier", 
                    "field", "fieldNotInit", "fieldSetted", "foreignField", 
                    "def", "justDef", "foreignDef", "inverseDefining", "inverseDefCompo", 
                    "inverseDefGateCompo", "lambda", "typeEx", "typeExSingle", 
                    "typeArgEx", "primitiveType", "typeExParamEx", "typeExFunc", 
                    "typeExCovariant", "typeExContravariant", "typeExWildcard", 
                    "foreignBody", "foreignElement", "foreignPlatform", 
                    "typeAlias", "foreignTypeExpectitive", "annotationDef", 
                    "annotation", "annotationBlock")

        private val LITERAL_NAMES: Array<String?> =
            arrayOf(null, null, null, null, "'abstract'", "'annotation'", 
                    "'class'", "'do'", "'foreign'", "'package'", "'internal'", 
                    "'import'", "'impl'", "'inherit'", "'return'", "'mutable'", 
                    "'interface'", "'data'", "'inverse'", "'expect'", "'if'", 
                    "'else'", "'new'", "'let'", "'typealias'", "'where'", 
                    "'from!'", "'is!'", "'get!'", "'set!'", "'remain!'", 
                    "'match!'", "'Int'", "'Long'", "'Double'", "'Float'", 
                    "'Byte'", "'Char'", "'String'", "'Boolean'", "'Unit'", 
                    "'null'", "'true'", "'false'", "'this'", "'|'", "'='", 
                    "'...'", "'.'", "'('", "')'", "'['", "']'", "'{'", "'}'", 
                    "'->'", "'->?'", "'~'", "'~>'", "':'", "'::'", "':::'", 
                    "':#'", "'''", "':''", "'#'", "'?'", "'!'")

        private val SYMBOLIC_NAMES: Array<String?> =
            arrayOf(null, "WS", "COMMENT", "LINE_COMMENT", "ABSTRACT", "ANNOTATION", 
                    "CLASS", "DO", "FOREIGN", "NAMESPACE", "INTERNAL", "IMPORT", 
                    "IMPL", "INHERIT", "RETURN", "MUTABLE", "INTERFACE", 
                    "DATA", "INVERSE", "EXPECT", "IF", "ELSE", "NEW", "LET", 
                    "TYPEALIAS", "WHERE", "FROM", "IS", "GET", "SET", "REMAIN", 
                    "MATCH", "INT", "LONG", "DOUBLE", "FLOAT", "BYTE", "CHAR", 
                    "STRING", "BOOLEAN", "UNIT", "NULLKEYWORD", "TRUE", 
                    "FALSE", "THIS", "PIPE", "ASSGIN", "ELLIPSIS", "DOT", 
                    "LPAREN", "RPAREN", "LSQUARE", "RSQUARE", "LBRACE", 
                    "RBRACE", "ARROW", "ARROWQM", "TILDE", "As", "COLON", 
                    "DOUBLECOLON", "TRIPLECOLON", "COLONSHARP", "QUOTE", 
                    "COLONQUOTE", "SHARP", "QM", "EM", "ID", "OPID", "Integer", 
                    "Double", "String", "RawString")

        private val VOCABULARY: Vocabulary = VocabularyImpl(LITERAL_NAMES, SYMBOLIC_NAMES)

        private val tokenNames: Array<String?> = Array(SYMBOLIC_NAMES.size) {
            VOCABULARY.getLiteralName(it)
                ?: VOCABULARY.getSymbolicName(it)
                ?: "<INVALID>"
        }

        private const val serializedATN: String =
            "\u0004\u0001\u0049\u047c\u0002\u0000\u0007\u0000\u0002\u0001\u0007\u0001\u0002\u0002\u0007\u0002\u0002\u0003\u0007\u0003\u0002\u0004\u0007\u0004\u0002\u0005\u0007\u0005\u0002\u0006\u0007\u0006\u0002\u0007\u0007\u0007\u0002\u0008\u0007\u0008\u0002\u0009\u0007\u0009\u0002\u000a\u0007\u000a\u0002\u000b\u0007\u000b\u0002\u000c\u0007\u000c\u0002\u000d\u0007\u000d\u0002\u000e\u0007\u000e\u0002\u000f\u0007\u000f\u0002\u0010\u0007\u0010\u0002\u0011\u0007\u0011\u0002\u0012\u0007\u0012\u0002\u0013\u0007\u0013\u0002\u0014\u0007\u0014\u0002\u0015\u0007\u0015\u0002\u0016\u0007\u0016\u0002\u0017\u0007\u0017\u0002\u0018\u0007\u0018\u0002\u0019\u0007\u0019\u0002\u001a\u0007\u001a\u0002\u001b\u0007\u001b\u0002\u001c\u0007\u001c\u0002\u001d\u0007\u001d\u0002\u001e\u0007\u001e\u0002\u001f\u0007\u001f\u0002\u0020\u0007\u0020\u0002\u0021\u0007\u0021\u0002\u0022\u0007\u0022\u0002\u0023\u0007\u0023\u0002\u0024\u0007\u0024\u0002\u0025\u0007\u0025\u0002\u0026\u0007\u0026\u0002\u0027\u0007\u0027\u0002\u0028\u0007\u0028\u0002\u0029\u0007\u0029\u0002\u002a\u0007\u002a\u0002\u002b\u0007\u002b\u0002\u002c\u0007\u002c\u0002\u002d\u0007\u002d\u0002\u002e\u0007\u002e\u0002\u002f\u0007\u002f\u0002\u0030\u0007\u0030\u0002\u0031\u0007\u0031\u0002\u0032\u0007\u0032\u0002\u0033\u0007\u0033\u0002\u0034\u0007\u0034\u0002\u0035\u0007\u0035\u0002\u0036\u0007\u0036\u0002\u0037\u0007\u0037\u0002\u0038\u0007\u0038\u0002\u0039\u0007\u0039\u0002\u003a\u0007\u003a\u0002\u003b\u0007\u003b\u0002\u003c\u0007\u003c\u0002\u003d\u0007\u003d\u0002\u003e\u0007\u003e\u0002\u003f\u0007\u003f\u0002\u0040\u0007\u0040\u0002\u0041\u0007\u0041\u0002\u0042\u0007\u0042\u0002\u0043\u0007\u0043\u0002\u0044\u0007\u0044\u0002\u0045\u0007\u0045\u0002\u0046\u0007\u0046\u0002\u0047\u0007\u0047\u0002\u0048\u0007\u0048\u0002\u0049\u0007\u0049\u0002\u004a\u0007\u004a\u0002\u004b\u0007\u004b\u0002\u004c\u0007\u004c\u0001\u0000\u0003\u0000\u009c\u0008\u0000\u0001\u0000\u0005\u0000\u009f\u0008\u0000\u000a\u0000\u000c\u0000\u00a2\u0009\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0005\u0000\u00a7\u0008\u0000\u000a\u0000\u000c\u0000\u00aa\u0009\u0000\u0001\u0001\u0001\u0001\u0001\u0001\u0003\u0001\u00af\u0008\u0001\u0001\u0002\u0001\u0002\u0001\u0002\u0003\u0002\u00b4\u0008\u0002\u0001\u0002\u0003\u0002\u00b7\u0008\u0002\u0001\u0002\u0003\u0002\u00ba\u0008\u0002\u0001\u0003\u0001\u0003\u0005\u0003\u00be\u0008\u0003\u000a\u0003\u000c\u0003\u00c1\u0009\u0003\u0001\u0003\u0001\u0003\u0001\u0004\u0001\u0004\u0001\u0004\u0003\u0004\u00c8\u0008\u0004\u0001\u0004\u0001\u0004\u0003\u0004\u00cc\u0008\u0004\u0001\u0004\u0001\u0004\u0001\u0004\u0001\u0004\u0003\u0004\u00d2\u0008\u0004\u0003\u0004\u00d4\u0008\u0004\u0001\u0005\u0001\u0005\u0001\u0006\u0001\u0006\u0001\u0007\u0001\u0007\u0001\u0008\u0001\u0008\u0001\u0008\u0001\u0008\u0001\u0008\u0001\u0009\u0001\u0009\u0001\u0009\u0003\u0009\u00e4\u0008\u0009\u0001\u000a\u0001\u000a\u0001\u000a\u0001\u000a\u0003\u000a\u00ea\u0008\u000a\u0001\u000b\u0001\u000b\u0001\u000b\u0005\u000b\u00ef\u0008\u000b\u000a\u000b\u000c\u000b\u00f2\u0009\u000b\u0001\u000c\u0001\u000c\u0001\u000c\u0001\u000d\u0001\u000d\u0001\u000d\u0005\u000d\u00fa\u0008\u000d\u000a\u000d\u000c\u000d\u00fd\u0009\u000d\u0001\u000d\u0001\u000d\u0001\u000e\u0001\u000e\u0001\u000e\u0001\u000e\u0003\u000e\u0105\u0008\u000e\u0001\u000f\u0001\u000f\u0001\u000f\u0001\u0010\u0001\u0010\u0001\u0010\u0001\u0011\u0001\u0011\u0001\u0011\u0001\u0011\u0001\u0011\u0001\u0011\u0001\u0011\u0001\u0011\u0001\u0011\u0001\u0011\u0003\u0011\u0117\u0008\u0011\u0001\u0012\u0003\u0012\u011a\u0008\u0012\u0001\u0012\u0003\u0012\u011d\u0008\u0012\u0001\u0012\u0003\u0012\u0120\u0008\u0012\u0001\u0012\u0001\u0012\u0001\u0012\u0001\u0012\u0001\u0012\u0001\u0012\u0003\u0012\u0128\u0008\u0012\u0001\u0012\u0001\u0012\u0001\u0012\u0005\u0012\u012d\u0008\u0012\u000a\u0012\u000c\u0012\u0130\u0009\u0012\u0001\u0012\u0001\u0012\u0001\u0012\u0003\u0012\u0135\u0008\u0012\u0005\u0012\u0137\u0008\u0012\u000a\u0012\u000c\u0012\u013a\u0009\u0012\u0001\u0012\u0005\u0012\u013d\u0008\u0012\u000a\u0012\u000c\u0012\u0140\u0009\u0012\u0001\u0012\u0001\u0012\u0001\u0012\u0003\u0012\u0145\u0008\u0012\u0001\u0012\u0003\u0012\u0148\u0008\u0012\u0001\u0012\u0001\u0012\u0001\u0012\u0001\u0012\u0001\u0012\u0001\u0012\u0003\u0012\u0150\u0008\u0012\u0001\u0012\u0001\u0012\u0001\u0012\u0001\u0012\u0005\u0012\u0156\u0008\u0012\u000a\u0012\u000c\u0012\u0159\u0009\u0012\u0001\u0012\u0001\u0012\u0005\u0012\u015d\u0008\u0012\u000a\u0012\u000c\u0012\u0160\u0009\u0012\u0001\u0012\u0001\u0012\u0003\u0012\u0164\u0008\u0012\u0001\u0012\u0005\u0012\u0167\u0008\u0012\u000a\u0012\u000c\u0012\u016a\u0009\u0012\u0001\u0012\u0001\u0012\u0001\u0012\u0003\u0012\u016f\u0008\u0012\u0001\u0012\u0003\u0012\u0172\u0008\u0012\u0001\u0012\u0003\u0012\u0175\u0008\u0012\u0001\u0012\u0001\u0012\u0001\u0012\u0001\u0012\u0001\u0012\u0001\u0012\u0003\u0012\u017d\u0008\u0012\u0001\u0012\u0001\u0012\u0003\u0012\u0181\u0008\u0012\u0001\u0012\u0001\u0012\u0001\u0012\u0003\u0012\u0186\u0008\u0012\u0005\u0012\u0188\u0008\u0012\u000a\u0012\u000c\u0012\u018b\u0009\u0012\u0001\u0012\u0001\u0012\u0001\u0012\u0003\u0012\u0190\u0008\u0012\u0005\u0012\u0192\u0008\u0012\u000a\u0012\u000c\u0012\u0195\u0009\u0012\u0001\u0012\u0003\u0012\u0198\u0008\u0012\u0001\u0012\u0005\u0012\u019b\u0008\u0012\u000a\u0012\u000c\u0012\u019e\u0009\u0012\u0001\u0012\u0001\u0012\u0003\u0012\u01a2\u0008\u0012\u0001\u0013\u0001\u0013\u0001\u0013\u0001\u0013\u0001\u0013\u0003\u0013\u01a9\u0008\u0013\u0001\u0013\u0003\u0013\u01ac\u0008\u0013\u0001\u0014\u0001\u0014\u0001\u0014\u0001\u0014\u0003\u0014\u01b2\u0008\u0014\u0001\u0014\u0003\u0014\u01b5\u0008\u0014\u0001\u0015\u0003\u0015\u01b8\u0008\u0015\u0001\u0015\u0001\u0015\u0003\u0015\u01bc\u0008\u0015\u0001\u0015\u0001\u0015\u0001\u0015\u0001\u0015\u0003\u0015\u01c2\u0008\u0015\u0001\u0015\u0001\u0015\u0001\u0016\u0001\u0016\u0001\u0016\u0001\u0016\u0001\u0016\u0001\u0016\u0001\u0017\u0001\u0017\u0001\u0017\u0001\u0017\u0003\u0017\u01d0\u0008\u0017\u0001\u0017\u0003\u0017\u01d3\u0008\u0017\u0001\u0017\u0001\u0017\u0003\u0017\u01d7\u0008\u0017\u0001\u0017\u0003\u0017\u01da\u0008\u0017\u0003\u0017\u01dc\u0008\u0017\u0001\u0018\u0001\u0018\u0001\u0018\u0001\u0018\u0003\u0018\u01e2\u0008\u0018\u0001\u0018\u0001\u0018\u0003\u0018\u01e6\u0008\u0018\u0003\u0018\u01e8\u0008\u0018\u0001\u0019\u0001\u0019\u0004\u0019\u01ec\u0008\u0019\u000b\u0019\u000c\u0019\u01ed\u0001\u0019\u0001\u0019\u0004\u0019\u01f2\u0008\u0019\u000b\u0019\u000c\u0019\u01f3\u0001\u0019\u0001\u0019\u0004\u0019\u01f8\u0008\u0019\u000b\u0019\u000c\u0019\u01f9\u0001\u0019\u0001\u0019\u0004\u0019\u01fe\u0008\u0019\u000b\u0019\u000c\u0019\u01ff\u0003\u0019\u0202\u0008\u0019\u0001\u001a\u0004\u001a\u0205\u0008\u001a\u000b\u001a\u000c\u001a\u0206\u0001\u001b\u0001\u001b\u0001\u001b\u0005\u001b\u020c\u0008\u001b\u000a\u001b\u000c\u001b\u020f\u0009\u001b\u0001\u001c\u0001\u001c\u0003\u001c\u0213\u0008\u001c\u0001\u001d\u0001\u001d\u0001\u001d\u0001\u001d\u0003\u001d\u0219\u0008\u001d\u0001\u001e\u0001\u001e\u0001\u001f\u0001\u001f\u0001\u001f\u0001\u001f\u0001\u001f\u0001\u001f\u0001\u001f\u0003\u001f\u0224\u0008\u001f\u0001\u001f\u0001\u001f\u0001\u001f\u0001\u001f\u0003\u001f\u022a\u0008\u001f\u0001\u001f\u0001\u001f\u0001\u001f\u0003\u001f\u022f\u0008\u001f\u0001\u001f\u0001\u001f\u0001\u001f\u0001\u001f\u0001\u001f\u0005\u001f\u0236\u0008\u001f\u000a\u001f\u000c\u001f\u0239\u0009\u001f\u0001\u001f\u0001\u001f\u0005\u001f\u023d\u0008\u001f\u000a\u001f\u000c\u001f\u0240\u0009\u001f\u0001\u001f\u0001\u001f\u0003\u001f\u0244\u0008\u001f\u0001\u001f\u0001\u001f\u0005\u001f\u0248\u0008\u001f\u000a\u001f\u000c\u001f\u024b\u0009\u001f\u0001\u001f\u0001\u001f\u0001\u001f\u0003\u001f\u0250\u0008\u001f\u0003\u001f\u0252\u0008\u001f\u0001\u001f\u0001\u001f\u0001\u001f\u0001\u001f\u0001\u001f\u0001\u001f\u0001\u001f\u0001\u001f\u0001\u001f\u0001\u001f\u0001\u001f\u0001\u001f\u0001\u001f\u0001\u001f\u0003\u001f\u0262\u0008\u001f\u0001\u001f\u0001\u001f\u0001\u001f\u0001\u001f\u0001\u001f\u0001\u001f\u0001\u001f\u0001\u001f\u0001\u001f\u0003\u001f\u026d\u0008\u001f\u0001\u001f\u0001\u001f\u0001\u001f\u0001\u001f\u0001\u001f\u0001\u001f\u0001\u001f\u0003\u001f\u0276\u0008\u001f\u0001\u001f\u0001\u001f\u0001\u001f\u0001\u001f\u0001\u001f\u0001\u001f\u0003\u001f\u027e\u0008\u001f\u0001\u001f\u0001\u001f\u0001\u001f\u0001\u001f\u0001\u001f\u0001\u001f\u0001\u001f\u0003\u001f\u0287\u0008\u001f\u0001\u001f\u0001\u001f\u0001\u001f\u0001\u001f\u0001\u001f\u0001\u001f\u0001\u001f\u0001\u001f\u0001\u001f\u0003\u001f\u0292\u0008\u001f\u0001\u001f\u0001\u001f\u0001\u001f\u0001\u001f\u0001\u001f\u0001\u001f\u0001\u001f\u0001\u001f\u0003\u001f\u029c\u0008\u001f\u0001\u001f\u0001\u001f\u0001\u001f\u0001\u001f\u0001\u001f\u0001\u001f\u0001\u001f\u0001\u001f\u0003\u001f\u02a6\u0008\u001f\u0005\u001f\u02a8\u0008\u001f\u000a\u001f\u000c\u001f\u02ab\u0009\u001f\u0001\u0020\u0001\u0020\u0001\u0020\u0003\u0020\u02b0\u0008\u0020\u0001\u0020\u0001\u0020\u0001\u0021\u0001\u0021\u0001\u0021\u0001\u0021\u0001\u0021\u0001\u0022\u0001\u0022\u0001\u0022\u0001\u0022\u0001\u0022\u0001\u0022\u0001\u0022\u0001\u0022\u0001\u0023\u0001\u0023\u0001\u0023\u0001\u0023\u0001\u0023\u0001\u0023\u0001\u0024\u0001\u0024\u0004\u0024\u02c9\u0008\u0024\u000b\u0024\u000c\u0024\u02ca\u0001\u0025\u0001\u0025\u0001\u0025\u0003\u0025\u02d0\u0008\u0025\u0001\u0025\u0001\u0025\u0001\u0025\u0001\u0026\u0001\u0026\u0001\u0026\u0005\u0026\u02d8\u0008\u0026\u000a\u0026\u000c\u0026\u02db\u0009\u0026\u0001\u0026\u0001\u0026\u0001\u0027\u0001\u0027\u0001\u0027\u0001\u0027\u0001\u0027\u0001\u0027\u0001\u0027\u0001\u0027\u0001\u0027\u0001\u0027\u0001\u0027\u0003\u0027\u02ea\u0008\u0027\u0001\u0027\u0001\u0027\u0001\u0027\u0001\u0027\u0001\u0027\u0001\u0027\u0001\u0027\u0001\u0027\u0001\u0027\u0003\u0027\u02f5\u0008\u0027\u0001\u0028\u0004\u0028\u02f8\u0008\u0028\u000b\u0028\u000c\u0028\u02f9\u0001\u0029\u0001\u0029\u0003\u0029\u02fe\u0008\u0029\u0001\u0029\u0003\u0029\u0301\u0008\u0029\u0001\u0029\u0001\u0029\u0001\u0029\u0003\u0029\u0306\u0008\u0029\u0001\u0029\u0001\u0029\u0005\u0029\u030a\u0008\u0029\u000a\u0029\u000c\u0029\u030d\u0009\u0029\u0001\u0029\u0003\u0029\u0310\u0008\u0029\u0001\u002a\u0001\u002a\u0005\u002a\u0314\u0008\u002a\u000a\u002a\u000c\u002a\u0317\u0009\u002a\u0001\u002a\u0003\u002a\u031a\u0008\u002a\u0001\u002a\u0005\u002a\u031d\u0008\u002a\u000a\u002a\u000c\u002a\u0320\u0009\u002a\u0001\u002a\u0001\u002a\u0001\u002a\u0005\u002a\u0325\u0008\u002a\u000a\u002a\u000c\u002a\u0328\u0009\u002a\u0001\u002a\u0003\u002a\u032b\u0008\u002a\u0001\u002a\u0005\u002a\u032e\u0008\u002a\u000a\u002a\u000c\u002a\u0331\u0009\u002a\u0001\u002a\u0003\u002a\u0334\u0008\u002a\u0001\u002b\u0001\u002b\u0001\u002b\u0005\u002b\u0339\u0008\u002b\u000a\u002b\u000c\u002b\u033c\u0009\u002b\u0001\u002b\u0001\u002b\u0001\u002c\u0001\u002c\u0001\u002c\u0001\u002c\u0003\u002c\u0344\u0008\u002c\u0001\u002d\u0001\u002d\u0001\u002d\u0003\u002d\u0349\u0008\u002d\u0001\u002e\u0001\u002e\u0001\u002e\u0001\u002e\u0001\u002f\u0001\u002f\u0001\u002f\u0001\u002f\u0001\u002f\u0001\u0030\u0001\u0030\u0001\u0030\u0001\u0030\u0003\u0030\u0358\u0008\u0030\u0001\u0031\u0001\u0031\u0001\u0031\u0003\u0031\u035d\u0008\u0031\u0001\u0032\u0001\u0032\u0001\u0032\u0003\u0032\u0362\u0008\u0032\u0001\u0032\u0001\u0032\u0001\u0032\u0001\u0033\u0001\u0033\u0001\u0033\u0003\u0033\u036a\u0008\u0033\u0001\u0033\u0001\u0033\u0001\u0033\u0001\u0033\u0001\u0033\u0001\u0034\u0001\u0034\u0001\u0034\u0001\u0034\u0001\u0034\u0001\u0034\u0001\u0034\u0001\u0034\u0003\u0034\u0379\u0008\u0034\u0001\u0034\u0001\u0034\u0001\u0034\u0001\u0034\u0003\u0034\u037f\u0008\u0034\u0001\u0035\u0001\u0035\u0005\u0035\u0383\u0008\u0035\u000a\u0035\u000c\u0035\u0386\u0009\u0035\u0001\u0035\u0001\u0035\u0005\u0035\u038a\u0008\u0035\u000a\u0035\u000c\u0035\u038d\u0009\u0035\u0003\u0035\u038f\u0008\u0035\u0001\u0036\u0003\u0036\u0392\u0008\u0036\u0001\u0036\u0001\u0036\u0003\u0036\u0396\u0008\u0036\u0001\u0036\u0001\u0036\u0001\u0036\u0001\u0036\u0003\u0036\u039c\u0008\u0036\u0001\u0036\u0001\u0036\u0001\u0036\u0001\u0036\u0001\u0037\u0003\u0037\u03a3\u0008\u0037\u0001\u0037\u0001\u0037\u0003\u0037\u03a7\u0008\u0037\u0001\u0037\u0001\u0037\u0001\u0037\u0001\u0037\u0003\u0037\u03ad\u0008\u0037\u0001\u0037\u0001\u0037\u0001\u0037\u0003\u0037\u03b2\u0008\u0037\u0001\u0038\u0001\u0038\u0003\u0038\u03b6\u0008\u0038\u0001\u0038\u0001\u0038\u0004\u0038\u03ba\u0008\u0038\u000b\u0038\u000c\u0038\u03bb\u0001\u0038\u0001\u0038\u0001\u0038\u0001\u0038\u0003\u0038\u03c2\u0008\u0038\u0001\u0038\u0001\u0038\u0004\u0038\u03c6\u0008\u0038\u000b\u0038\u000c\u0038\u03c7\u0001\u0038\u0001\u0038\u0001\u0038\u0003\u0038\u03cd\u0008\u0038\u0001\u0039\u0001\u0039\u0001\u0039\u0003\u0039\u03d2\u0008\u0039\u0001\u0039\u0001\u0039\u0003\u0039\u03d6\u0008\u0039\u0001\u003a\u0001\u003a\u0001\u003a\u0003\u003a\u03db\u0008\u003a\u0001\u003a\u0001\u003a\u0003\u003a\u03df\u0008\u003a\u0001\u003b\u0001\u003b\u0003\u003b\u03e3\u0008\u003b\u0001\u003b\u0001\u003b\u0001\u003b\u0001\u003c\u0001\u003c\u0001\u003c\u0001\u003c\u0001\u003c\u0003\u003c\u03ed\u0008\u003c\u0003\u003c\u03ef\u0008\u003c\u0001\u003c\u0001\u003c\u0003\u003c\u03f3\u0008\u003c\u0003\u003c\u03f5\u0008\u003c\u0001\u003d\u0001\u003d\u0001\u003d\u0003\u003d\u03fa\u0008\u003d\u0001\u003d\u0001\u003d\u0001\u003d\u0004\u003d\u03ff\u0008\u003d\u000b\u003d\u000c\u003d\u0400\u0001\u003d\u0001\u003d\u0003\u003d\u0405\u0008\u003d\u0001\u003d\u0003\u003d\u0408\u0008\u003d\u0001\u003e\u0001\u003e\u0001\u003e\u0001\u003e\u0003\u003e\u040e\u0008\u003e\u0001\u003f\u0001\u003f\u0001\u0040\u0001\u0040\u0003\u0040\u0414\u0008\u0040\u0001\u0041\u0001\u0041\u0005\u0041\u0418\u0008\u0041\u000a\u0041\u000c\u0041\u041b\u0009\u0041\u0001\u0041\u0001\u0041\u0001\u0041\u0001\u0041\u0001\u0042\u0001\u0042\u0001\u0042\u0001\u0042\u0001\u0042\u0001\u0043\u0001\u0043\u0001\u0043\u0001\u0043\u0001\u0043\u0001\u0044\u0001\u0044\u0001\u0044\u0001\u0044\u0001\u0045\u0001\u0045\u0005\u0045\u0431\u0008\u0045\u000a\u0045\u000c\u0045\u0434\u0009\u0045\u0001\u0045\u0001\u0045\u0003\u0045\u0438\u0008\u0045\u0001\u0046\u0001\u0046\u0001\u0046\u0001\u0047\u0001\u0047\u0001\u0048\u0001\u0048\u0001\u0048\u0001\u0048\u0001\u0048\u0001\u0048\u0003\u0048\u0445\u0008\u0048\u0001\u0048\u0001\u0048\u0001\u0048\u0001\u0048\u0003\u0048\u044b\u0008\u0048\u0001\u0048\u0003\u0048\u044e\u0008\u0048\u0003\u0048\u0450\u0008\u0048\u0001\u0049\u0001\u0049\u0001\u0049\u0001\u0049\u0005\u0049\u0456\u0008\u0049\u000a\u0049\u000c\u0049\u0459\u0009\u0049\u0001\u0049\u0001\u0049\u0005\u0049\u045d\u0008\u0049\u000a\u0049\u000c\u0049\u0460\u0009\u0049\u0001\u0049\u0001\u0049\u0001\u004a\u0001\u004a\u0001\u004a\u0001\u004a\u0001\u004a\u0001\u004a\u0001\u004b\u0001\u004b\u0001\u004b\u0003\u004b\u046d\u0008\u004b\u0001\u004b\u0001\u004b\u0003\u004b\u0471\u0008\u004b\u0001\u004c\u0001\u004c\u0005\u004c\u0475\u0008\u004c\u000a\u004c\u000c\u004c\u0478\u0009\u004c\u0001\u004c\u0001\u004c\u0001\u004c\u0000\u0001\u003e\u004d\u0000\u0002\u0004\u0006\u0008\u000a\u000c\u000e\u0010\u0012\u0014\u0016\u0018\u001a\u001c\u001e\u0020\u0022\u0024\u0026\u0028\u002a\u002c\u002e\u0030\u0032\u0034\u0036\u0038\u003a\u003c\u003e\u0040\u0042\u0044\u0046\u0048\u004a\u004c\u004e\u0050\u0052\u0054\u0056\u0058\u005a\u005c\u005e\u0060\u0062\u0064\u0066\u0068\u006a\u006c\u006e\u0070\u0072\u0074\u0076\u0078\u007a\u007c\u007e\u0080\u0082\u0084\u0086\u0088\u008a\u008c\u008e\u0090\u0092\u0094\u0096\u0098\u0000\u0003\u0001\u0000\u002a\u002b\u0002\u0000\u0042\u0042\u0044\u0044\u0001\u0000\u0020\u0028\u04f2\u0000\u009b\u0001\u0000\u0000\u0000\u0002\u00ae\u0001\u0000\u0000\u0000\u0004\u00b0\u0001\u0000\u0000\u0000\u0006\u00bb\u0001\u0000\u0000\u0000\u0008\u00d3\u0001\u0000\u0000\u0000\u000a\u00d5\u0001\u0000\u0000\u0000\u000c\u00d7\u0001\u0000\u0000\u0000\u000e\u00d9\u0001\u0000\u0000\u0000\u0010\u00db\u0001\u0000\u0000\u0000\u0012\u00e3\u0001\u0000\u0000\u0000\u0014\u00e9\u0001\u0000\u0000\u0000\u0016\u00eb\u0001\u0000\u0000\u0000\u0018\u00f3\u0001\u0000\u0000\u0000\u001a\u00f6\u0001\u0000\u0000\u0000\u001c\u0104\u0001\u0000\u0000\u0000\u001e\u0106\u0001\u0000\u0000\u0000\u0020\u0109\u0001\u0000\u0000\u0000\u0022\u0116\u0001\u0000\u0000\u0000\u0024\u01a1\u0001\u0000\u0000\u0000\u0026\u01a3\u0001\u0000\u0000\u0000\u0028\u01b1\u0001\u0000\u0000\u0000\u002a\u01b7\u0001\u0000\u0000\u0000\u002c\u01c5\u0001\u0000\u0000\u0000\u002e\u01cb\u0001\u0000\u0000\u0000\u0030\u01dd\u0001\u0000\u0000\u0000\u0032\u0201\u0001\u0000\u0000\u0000\u0034\u0204\u0001\u0000\u0000\u0000\u0036\u0208\u0001\u0000\u0000\u0000\u0038\u0212\u0001\u0000\u0000\u0000\u003a\u0218\u0001\u0000\u0000\u0000\u003c\u021a\u0001\u0000\u0000\u0000\u003e\u0261\u0001\u0000\u0000\u0000\u0040\u02af\u0001\u0000\u0000\u0000\u0042\u02b3\u0001\u0000\u0000\u0000\u0044\u02b8\u0001\u0000\u0000\u0000\u0046\u02c0\u0001\u0000\u0000\u0000\u0048\u02c6\u0001\u0000\u0000\u0000\u004a\u02cc\u0001\u0000\u0000\u0000\u004c\u02d4\u0001\u0000\u0000\u0000\u004e\u02f4\u0001\u0000\u0000\u0000\u0050\u02f7\u0001\u0000\u0000\u0000\u0052\u030f\u0001\u0000\u0000\u0000\u0054\u0333\u0001\u0000\u0000\u0000\u0056\u0335\u0001\u0000\u0000\u0000\u0058\u0343\u0001\u0000\u0000\u0000\u005a\u0348\u0001\u0000\u0000\u0000\u005c\u034a\u0001\u0000\u0000\u0000\u005e\u034e\u0001\u0000\u0000\u0000\u0060\u0357\u0001\u0000\u0000\u0000\u0062\u035c\u0001\u0000\u0000\u0000\u0064\u0361\u0001\u0000\u0000\u0000\u0066\u0369\u0001\u0000\u0000\u0000\u0068\u0370\u0001\u0000\u0000\u0000\u006a\u038e\u0001\u0000\u0000\u0000\u006c\u0391\u0001\u0000\u0000\u0000\u006e\u03a2\u0001\u0000\u0000\u0000\u0070\u03cc\u0001\u0000\u0000\u0000\u0072\u03d5\u0001\u0000\u0000\u0000\u0074\u03de\u0001\u0000\u0000\u0000\u0076\u03e0\u0001\u0000\u0000\u0000\u0078\u03f4\u0001\u0000\u0000\u0000\u007a\u0407\u0001\u0000\u0000\u0000\u007c\u040d\u0001\u0000\u0000\u0000\u007e\u040f\u0001\u0000\u0000\u0000\u0080\u0411\u0001\u0000\u0000\u0000\u0082\u0415\u0001\u0000\u0000\u0000\u0084\u0420\u0001\u0000\u0000\u0000\u0086\u0425\u0001\u0000\u0000\u0000\u0088\u042a\u0001\u0000\u0000\u0000\u008a\u0437\u0001\u0000\u0000\u0000\u008c\u0439\u0001\u0000\u0000\u0000\u008e\u043c\u0001\u0000\u0000\u0000\u0090\u043e\u0001\u0000\u0000\u0000\u0092\u0451\u0001\u0000\u0000\u0000\u0094\u0463\u0001\u0000\u0000\u0000\u0096\u046c\u0001\u0000\u0000\u0000\u0098\u0472\u0001\u0000\u0000\u0000\u009a\u009c\u0003\u0018\u000c\u0000\u009b\u009a\u0001\u0000\u0000\u0000\u009b\u009c\u0001\u0000\u0000\u0000\u009c\u00a0\u0001\u0000\u0000\u0000\u009d\u009f\u0003\u0004\u0002\u0000\u009e\u009d\u0001\u0000\u0000\u0000\u009f\u00a2\u0001\u0000\u0000\u0000\u00a0\u009e\u0001\u0000\u0000\u0000\u00a0\u00a1\u0001\u0000\u0000\u0000\u00a1\u00a8\u0001\u0000\u0000\u0000\u00a2\u00a0\u0001\u0000\u0000\u0000\u00a3\u00a7\u0003\u0002\u0001\u0000\u00a4\u00a7\u0003\u0094\u004a\u0000\u00a5\u00a7\u0003\u0090\u0048\u0000\u00a6\u00a3\u0001\u0000\u0000\u0000\u00a6\u00a4\u0001\u0000\u0000\u0000\u00a6\u00a5\u0001\u0000\u0000\u0000\u00a7\u00aa\u0001\u0000\u0000\u0000\u00a8\u00a6\u0001\u0000\u0000\u0000\u00a8\u00a9\u0001\u0000\u0000\u0000\u00a9\u0001\u0001\u0000\u0000\u0000\u00aa\u00a8\u0001\u0000\u0000\u0000\u00ab\u00af\u0003\u0038\u001c\u0000\u00ac\u00ad\u0005\u0041\u0000\u0000\u00ad\u00af\u0003\u0062\u0031\u0000\u00ae\u00ab\u0001\u0000\u0000\u0000\u00ae\u00ac\u0001\u0000\u0000\u0000\u00af\u0003\u0001\u0000\u0000\u0000\u00b0\u00b1\u0005\u000b\u0000\u0000\u00b1\u00b3\u0003\u0016\u000b\u0000\u00b2\u00b4\u0003\u0012\u0009\u0000\u00b3\u00b2\u0001\u0000\u0000\u0000\u00b3\u00b4\u0001\u0000\u0000\u0000\u00b4\u00b6\u0001\u0000\u0000\u0000\u00b5\u00b7\u0003\u0010\u0008\u0000\u00b6\u00b5\u0001\u0000\u0000\u0000\u00b6\u00b7\u0001\u0000\u0000\u0000\u00b7\u00b9\u0001\u0000\u0000\u0000\u00b8\u00ba\u0003\u0006\u0003\u0000\u00b9\u00b8\u0001\u0000\u0000\u0000\u00b9\u00ba\u0001\u0000\u0000\u0000\u00ba\u0005\u0001\u0000\u0000\u0000\u00bb\u00bf\u0005\u0035\u0000\u0000\u00bc\u00be\u0003\u0008\u0004\u0000\u00bd\u00bc\u0001\u0000\u0000\u0000\u00be\u00c1\u0001\u0000\u0000\u0000\u00bf\u00bd\u0001\u0000\u0000\u0000\u00bf\u00c0\u0001\u0000\u0000\u0000\u00c0\u00c2\u0001\u0000\u0000\u0000\u00c1\u00bf\u0001\u0000\u0000\u0000\u00c2\u00c3\u0005\u0036\u0000\u0000\u00c3\u0007\u0001\u0000\u0000\u0000\u00c4\u00c7\u0003\u005a\u002d\u0000\u00c5\u00c6\u0005\u0041\u0000\u0000\u00c6\u00c8\u0003\u000a\u0005\u0000\u00c7\u00c5\u0001\u0000\u0000\u0000\u00c7\u00c8\u0001\u0000\u0000\u0000\u00c8\u00cb\u0001\u0000\u0000\u0000\u00c9\u00ca\u0005\u003a\u0000\u0000\u00ca\u00cc\u0003\u000e\u0007\u0000\u00cb\u00c9\u0001\u0000\u0000\u0000\u00cb\u00cc\u0001\u0000\u0000\u0000\u00cc\u00d4\u0001\u0000\u0000\u0000\u00cd\u00ce\u0005\u0006\u0000\u0000\u00ce\u00d1\u0003\u0060\u0030\u0000\u00cf\u00d0\u0005\u0041\u0000\u0000\u00d0\u00d2\u0003\u000c\u0006\u0000\u00d1\u00cf\u0001\u0000\u0000\u0000\u00d1\u00d2\u0001\u0000\u0000\u0000\u00d2\u00d4\u0001\u0000\u0000\u0000\u00d3\u00c4\u0001\u0000\u0000\u0000\u00d3\u00cd\u0001\u0000\u0000\u0000\u00d4\u0009\u0001\u0000\u0000\u0000\u00d5\u00d6\u0003\u005a\u002d\u0000\u00d6\u000b\u0001\u0000\u0000\u0000\u00d7\u00d8\u0003\u0060\u0030\u0000\u00d8\u000d\u0001\u0000\u0000\u0000\u00d9\u00da\u0003\u0078\u003c\u0000\u00da\u000f\u0001\u0000\u0000\u0000\u00db\u00dc\u0005\u0031\u0000\u0000\u00dc\u00dd\u0005\u001a\u0000\u0000\u00dd\u00de\u0005\u0049\u0000\u0000\u00de\u00df\u0005\u0032\u0000\u0000\u00df\u0011\u0001\u0000\u0000\u0000\u00e0\u00e1\u0005\u0041\u0000\u0000\u00e1\u00e4\u0005\u0044\u0000\u0000\u00e2\u00e4\u0005\u0043\u0000\u0000\u00e3\u00e0\u0001\u0000\u0000\u0000\u00e3\u00e2\u0001\u0000\u0000\u0000\u00e4\u0013\u0001\u0000\u0000\u0000\u00e5\u00ea\u0005\u0044\u0000\u0000\u00e6\u00e7\u0005\u0035\u0000\u0000\u00e7\u00e8\u0005\u0044\u0000\u0000\u00e8\u00ea\u0005\u0036\u0000\u0000\u00e9\u00e5\u0001\u0000\u0000\u0000\u00e9\u00e6\u0001\u0000\u0000\u0000\u00ea\u0015\u0001\u0000\u0000\u0000\u00eb\u00f0\u0003\u0014\u000a\u0000\u00ec\u00ed\u0005\u0030\u0000\u0000\u00ed\u00ef\u0003\u0014\u000a\u0000\u00ee\u00ec\u0001\u0000\u0000\u0000\u00ef\u00f2\u0001\u0000\u0000\u0000\u00f0\u00ee\u0001\u0000\u0000\u0000\u00f0\u00f1\u0001\u0000\u0000\u0000\u00f1\u0017\u0001\u0000\u0000\u0000\u00f2\u00f0\u0001\u0000\u0000\u0000\u00f3\u00f4\u0005\u0009\u0000\u0000\u00f4\u00f5\u0003\u0016\u000b\u0000\u00f5\u0019\u0001\u0000\u0000\u0000\u00f6\u00f7\u0005\u0007\u0000\u0000\u00f7\u00fb\u0005\u0035\u0000\u0000\u00f8\u00fa\u0003\u001c\u000e\u0000\u00f9\u00f8\u0001\u0000\u0000\u0000\u00fa\u00fd\u0001\u0000\u0000\u0000\u00fb\u00f9\u0001\u0000\u0000\u0000\u00fb\u00fc\u0001\u0000\u0000\u0000\u00fc\u00fe\u0001\u0000\u0000\u0000\u00fd\u00fb\u0001\u0000\u0000\u0000\u00fe\u00ff\u0005\u0036\u0000\u0000\u00ff\u001b\u0001\u0000\u0000\u0000\u0100\u0105\u0003\u0022\u0011\u0000\u0101\u0105\u0003\u001e\u000f\u0000\u0102\u0105\u0003\u003e\u001f\u0000\u0103\u0105\u0003\u0020\u0010\u0000\u0104\u0100\u0001\u0000\u0000\u0000\u0104\u0101\u0001\u0000\u0000\u0000\u0104\u0102\u0001\u0000\u0000\u0000\u0104\u0103\u0001\u0000\u0000\u0000\u0105\u001d\u0001\u0000\u0000\u0000\u0106\u0107\u0005\u001e\u0000\u0000\u0107\u0108\u0003\u0046\u0023\u0000\u0108\u001f\u0001\u0000\u0000\u0000\u0109\u010a\u0005\u000e\u0000\u0000\u010a\u010b\u0003\u003e\u001f\u0000\u010b\u0021\u0001\u0000\u0000\u0000\u010c\u010d\u0005\u0041\u0000\u0000\u010d\u010e\u0005\u0044\u0000\u0000\u010e\u010f\u0005\u002e\u0000\u0000\u010f\u0117\u0003\u003e\u001f\u0000\u0110\u0111\u0003\u003e\u001f\u0000\u0111\u0112\u0005\u003e\u0000\u0000\u0112\u0113\u0005\u0044\u0000\u0000\u0113\u0114\u0005\u002e\u0000\u0000\u0114\u0115\u0003\u003e\u001f\u0000\u0115\u0117\u0001\u0000\u0000\u0000\u0116\u010c\u0001\u0000\u0000\u0000\u0116\u0110\u0001\u0000\u0000\u0000\u0117\u0023\u0001\u0000\u0000\u0000\u0118\u011a\u0003\u0098\u004c\u0000\u0119\u0118\u0001\u0000\u0000\u0000\u0119\u011a\u0001\u0000\u0000\u0000\u011a\u011c\u0001\u0000\u0000\u0000\u011b\u011d\u0005\u0004\u0000\u0000\u011c\u011b\u0001\u0000\u0000\u0000\u011c\u011d\u0001\u0000\u0000\u0000\u011d\u011f\u0001\u0000\u0000\u0000\u011e\u0120\u0005\u0010\u0000\u0000\u011f\u011e\u0001\u0000\u0000\u0000\u011f\u0120\u0001\u0000\u0000\u0000\u0120\u0121\u0001\u0000\u0000\u0000\u0121\u0122\u0005\u0006\u0000\u0000\u0122\u0127\u0003\u0060\u0030\u0000\u0123\u0124\u0005\u0031\u0000\u0000\u0124\u0125\u0003\u0034\u001a\u0000\u0125\u0126\u0005\u0032\u0000\u0000\u0126\u0128\u0001\u0000\u0000\u0000\u0127\u0123\u0001\u0000\u0000\u0000\u0127\u0128\u0001\u0000\u0000\u0000\u0128\u0129\u0001\u0000\u0000\u0000\u0129\u012e\u0005\u0035\u0000\u0000\u012a\u012b\u0005\u003e\u0000\u0000\u012b\u012d\u0003\u002c\u0016\u0000\u012c\u012a\u0001\u0000\u0000\u0000\u012d\u0130\u0001\u0000\u0000\u0000\u012e\u012c\u0001\u0000\u0000\u0000\u012e\u012f\u0001\u0000\u0000\u0000\u012f\u0138\u0001\u0000\u0000\u0000\u0130\u012e\u0001\u0000\u0000\u0000\u0131\u0134\u0005\u003b\u0000\u0000\u0132\u0135\u0003\u002a\u0015\u0000\u0133\u0135\u0003\u006a\u0035\u0000\u0134\u0132\u0001\u0000\u0000\u0000\u0134\u0133\u0001\u0000\u0000\u0000\u0135\u0137\u0001\u0000\u0000\u0000\u0136\u0131\u0001\u0000\u0000\u0000\u0137\u013a\u0001\u0000\u0000\u0000\u0138\u0136\u0001\u0000\u0000\u0000\u0138\u0139\u0001\u0000\u0000\u0000\u0139\u013e\u0001\u0000\u0000\u0000\u013a\u0138\u0001\u0000\u0000\u0000\u013b\u013d\u0003\u0030\u0018\u0000\u013c\u013b\u0001\u0000\u0000\u0000\u013d\u0140\u0001\u0000\u0000\u0000\u013e\u013c\u0001\u0000\u0000\u0000\u013e\u013f\u0001\u0000\u0000\u0000\u013f\u0141\u0001\u0000\u0000\u0000\u0140\u013e\u0001\u0000\u0000\u0000\u0141\u0142\u0005\u0036\u0000\u0000\u0142\u01a2\u0001\u0000\u0000\u0000\u0143\u0145\u0003\u0098\u004c\u0000\u0144\u0143\u0001\u0000\u0000\u0000\u0144\u0145\u0001\u0000\u0000\u0000\u0145\u0147\u0001\u0000\u0000\u0000\u0146\u0148\u0005\u0011\u0000\u0000\u0147\u0146\u0001\u0000\u0000\u0000\u0147\u0148\u0001\u0000\u0000\u0000\u0148\u0149\u0001\u0000\u0000\u0000\u0149\u014a\u0005\u0006\u0000\u0000\u014a\u014f\u0003\u0060\u0030\u0000\u014b\u014c\u0005\u0031\u0000\u0000\u014c\u014d\u0003\u0034\u001a\u0000\u014d\u014e\u0005\u0032\u0000\u0000\u014e\u0150\u0001\u0000\u0000\u0000\u014f\u014b\u0001\u0000\u0000\u0000\u014f\u0150\u0001\u0000\u0000\u0000\u0150\u0151\u0001\u0000\u0000\u0000\u0151\u0152\u0005\u0035\u0000\u0000\u0152\u0157\u0003\u0028\u0014\u0000\u0153\u0154\u0005\u003e\u0000\u0000\u0154\u0156\u0003\u0062\u0031\u0000\u0155\u0153\u0001\u0000\u0000\u0000\u0156\u0159\u0001\u0000\u0000\u0000\u0157\u0155\u0001\u0000\u0000\u0000\u0157\u0158\u0001\u0000\u0000\u0000\u0158\u015e\u0001\u0000\u0000\u0000\u0159\u0157\u0001\u0000\u0000\u0000\u015a\u015b\u0005\u003b\u0000\u0000\u015b\u015d\u0003\u006a\u0035\u0000\u015c\u015a\u0001\u0000\u0000\u0000\u015d\u0160\u0001\u0000\u0000\u0000\u015e\u015c\u0001\u0000\u0000\u0000\u015e\u015f\u0001\u0000\u0000\u0000\u015f\u0163\u0001\u0000\u0000\u0000\u0160\u015e\u0001\u0000\u0000\u0000\u0161\u0162\u0005\u000d\u0000\u0000\u0162\u0164\u0003\u002e\u0017\u0000\u0163\u0161\u0001\u0000\u0000\u0000\u0163\u0164\u0001\u0000\u0000\u0000\u0164\u0168\u0001\u0000\u0000\u0000\u0165\u0167\u0003\u0030\u0018\u0000\u0166\u0165\u0001\u0000\u0000\u0000\u0167\u016a\u0001\u0000\u0000\u0000\u0168\u0166\u0001\u0000\u0000\u0000\u0168\u0169\u0001\u0000\u0000\u0000\u0169\u016b\u0001\u0000\u0000\u0000\u016a\u0168\u0001\u0000\u0000\u0000\u016b\u016c\u0005\u0036\u0000\u0000\u016c\u01a2\u0001\u0000\u0000\u0000\u016d\u016f\u0003\u0098\u004c\u0000\u016e\u016d\u0001\u0000\u0000\u0000\u016e\u016f\u0001\u0000\u0000\u0000\u016f\u0171\u0001\u0000\u0000\u0000\u0170\u0172\u0005\u0004\u0000\u0000\u0171\u0170\u0001\u0000\u0000\u0000\u0171\u0172\u0001\u0000\u0000\u0000\u0172\u0174\u0001\u0000\u0000\u0000\u0173\u0175\u0005\u0011\u0000\u0000\u0174\u0173\u0001\u0000\u0000\u0000\u0174\u0175\u0001\u0000\u0000\u0000\u0175\u0176\u0001\u0000\u0000\u0000\u0176\u0177\u0005\u0006\u0000\u0000\u0177\u017c\u0003\u0060\u0030\u0000\u0178\u0179\u0005\u0031\u0000\u0000\u0179\u017a\u0003\u0034\u001a\u0000\u017a\u017b\u0005\u0032\u0000\u0000\u017b\u017d\u0001\u0000\u0000\u0000\u017c\u0178\u0001\u0000\u0000\u0000\u017c\u017d\u0001\u0000\u0000\u0000\u017d\u017e\u0001\u0000\u0000\u0000\u017e\u0180\u0005\u0035\u0000\u0000\u017f\u0181\u0003\u0028\u0014\u0000\u0180\u017f\u0001\u0000\u0000\u0000\u0180\u0181\u0001\u0000\u0000\u0000\u0181\u0189\u0001\u0000\u0000\u0000\u0182\u0185\u0005\u003e\u0000\u0000\u0183\u0186\u0003\u0062\u0031\u0000\u0184\u0186\u0003\u002c\u0016\u0000\u0185\u0183\u0001\u0000\u0000\u0000\u0185\u0184\u0001\u0000\u0000\u0000\u0186\u0188\u0001\u0000\u0000\u0000\u0187\u0182\u0001\u0000\u0000\u0000\u0188\u018b\u0001\u0000\u0000\u0000\u0189\u0187\u0001\u0000\u0000\u0000\u0189\u018a\u0001\u0000\u0000\u0000\u018a\u0193\u0001\u0000\u0000\u0000\u018b\u0189\u0001\u0000\u0000\u0000\u018c\u018f\u0005\u003b\u0000\u0000\u018d\u0190\u0003\u002a\u0015\u0000\u018e\u0190\u0003\u006a\u0035\u0000\u018f\u018d\u0001\u0000\u0000\u0000\u018f\u018e\u0001\u0000\u0000\u0000\u0190\u0192\u0001\u0000\u0000\u0000\u0191\u018c\u0001\u0000\u0000\u0000\u0192\u0195\u0001\u0000\u0000\u0000\u0193\u0191\u0001\u0000\u0000\u0000\u0193\u0194\u0001\u0000\u0000\u0000\u0194\u0197\u0001\u0000\u0000\u0000\u0195\u0193\u0001\u0000\u0000\u0000\u0196\u0198\u0003\u002e\u0017\u0000\u0197\u0196\u0001\u0000\u0000\u0000\u0197\u0198\u0001\u0000\u0000\u0000\u0198\u019c\u0001\u0000\u0000\u0000\u0199\u019b\u0003\u0030\u0018\u0000\u019a\u0199\u0001\u0000\u0000\u0000\u019b\u019e\u0001\u0000\u0000\u0000\u019c\u019a\u0001\u0000\u0000\u0000\u019c\u019d\u0001\u0000\u0000\u0000\u019d\u019f\u0001\u0000\u0000\u0000\u019e\u019c\u0001\u0000\u0000\u0000\u019f\u01a0\u0005\u0036\u0000\u0000\u01a0\u01a2\u0001\u0000\u0000\u0000\u01a1\u0119\u0001\u0000\u0000\u0000\u01a1\u0144\u0001\u0000\u0000\u0000\u01a1\u016e\u0001\u0000\u0000\u0000\u01a2\u0025\u0001\u0000\u0000\u0000\u01a3\u01a8\u0005\u0044\u0000\u0000\u01a4\u01a5\u0005\u0031\u0000\u0000\u01a5\u01a6\u0003\u0050\u0028\u0000\u01a6\u01a7\u0005\u0032\u0000\u0000\u01a7\u01a9\u0001\u0000\u0000\u0000\u01a8\u01a4\u0001\u0000\u0000\u0000\u01a8\u01a9\u0001\u0000\u0000\u0000\u01a9\u01ab\u0001\u0000\u0000\u0000\u01aa\u01ac\u0003\u001a\u000d\u0000\u01ab\u01aa\u0001\u0000\u0000\u0000\u01ab\u01ac\u0001\u0000\u0000\u0000\u01ac\u0027\u0001\u0000\u0000\u0000\u01ad\u01ae\u0005\u0031\u0000\u0000\u01ae\u01af\u0003\u0050\u0028\u0000\u01af\u01b0\u0005\u0032\u0000\u0000\u01b0\u01b2\u0001\u0000\u0000\u0000\u01b1\u01ad\u0001\u0000\u0000\u0000\u01b1\u01b2\u0001\u0000\u0000\u0000\u01b2\u01b4\u0001\u0000\u0000\u0000\u01b3\u01b5\u0003\u001a\u000d\u0000\u01b4\u01b3\u0001\u0000\u0000\u0000\u01b4\u01b5\u0001\u0000\u0000\u0000\u01b5\u0029\u0001\u0000\u0000\u0000\u01b6\u01b8\u0003\u0098\u004c\u0000\u01b7\u01b6\u0001\u0000\u0000\u0000\u01b7\u01b8\u0001\u0000\u0000\u0000\u01b8\u01b9\u0001\u0000\u0000\u0000\u01b9\u01bb\u0003\u005a\u002d\u0000\u01ba\u01bc\u0003\u0034\u001a\u0000\u01bb\u01ba\u0001\u0000\u0000\u0000\u01bb\u01bc\u0001\u0000\u0000\u0000\u01bc\u01c1\u0001\u0000\u0000\u0000\u01bd\u01be\u0005\u0031\u0000\u0000\u01be\u01bf\u0003\u0050\u0028\u0000\u01bf\u01c0\u0005\u0032\u0000\u0000\u01c0\u01c2\u0001\u0000\u0000\u0000\u01c1\u01bd\u0001\u0000\u0000\u0000\u01c1\u01c2\u0001\u0000\u0000\u0000\u01c2\u01c3\u0001\u0000\u0000\u0000\u01c3\u01c4\u0003\u0078\u003c\u0000\u01c4\u002b\u0001\u0000\u0000\u0000\u01c5\u01c6\u0005\u0031\u0000\u0000\u01c6\u01c7\u0005\u0004\u0000\u0000\u01c7\u01c8\u0005\u0032\u0000\u0000\u01c8\u01c9\u0001\u0000\u0000\u0000\u01c9\u01ca\u0003\u0064\u0032\u0000\u01ca\u002d\u0001\u0000\u0000\u0000\u01cb\u01cc\u0005\u000d\u0000\u0000\u01cc\u01db\u0003\u0078\u003c\u0000\u01cd\u01cf\u0005\u0035\u0000\u0000\u01ce\u01d0\u0003\u0054\u002a\u0000\u01cf\u01ce\u0001\u0000\u0000\u0000\u01cf\u01d0\u0001\u0000\u0000\u0000\u01d0\u01d2\u0001\u0000\u0000\u0000\u01d1\u01d3\u0003\u0032\u0019\u0000\u01d2\u01d1\u0001\u0000\u0000\u0000\u01d2\u01d3\u0001\u0000\u0000\u0000\u01d3\u01d4\u0001\u0000\u0000\u0000\u01d4\u01dc\u0005\u0036\u0000\u0000\u01d5\u01d7\u0003\u0054\u002a\u0000\u01d6\u01d5\u0001\u0000\u0000\u0000\u01d6\u01d7\u0001\u0000\u0000\u0000\u01d7\u01d9\u0001\u0000\u0000\u0000\u01d8\u01da\u0003\u0032\u0019\u0000\u01d9\u01d8\u0001\u0000\u0000\u0000\u01d9\u01da\u0001\u0000\u0000\u0000\u01da\u01dc\u0001\u0000\u0000\u0000\u01db\u01cd\u0001\u0000\u0000\u0000\u01db\u01d6\u0001\u0000\u0000\u0000\u01dc\u002f\u0001\u0000\u0000\u0000\u01dd\u01de\u0005\u000c\u0000\u0000\u01de\u01e7\u0003\u0078\u003c\u0000\u01df\u01e1\u0005\u0035\u0000\u0000\u01e0\u01e2\u0003\u0032\u0019\u0000\u01e1\u01e0\u0001\u0000\u0000\u0000\u01e1\u01e2\u0001\u0000\u0000\u0000\u01e2\u01e3\u0001\u0000\u0000\u0000\u01e3\u01e8\u0005\u0036\u0000\u0000\u01e4\u01e6\u0003\u0032\u0019\u0000\u01e5\u01e4\u0001\u0000\u0000\u0000\u01e5\u01e6\u0001\u0000\u0000\u0000\u01e6\u01e8\u0001\u0000\u0000\u0000\u01e7\u01df\u0001\u0000\u0000\u0000\u01e7\u01e5\u0001\u0000\u0000\u0000\u01e8\u0031\u0001\u0000\u0000\u0000\u01e9\u01ea\u0005\u003e\u0000\u0000\u01ea\u01ec\u0003\u0062\u0031\u0000\u01eb\u01e9\u0001\u0000\u0000\u0000\u01ec\u01ed\u0001\u0000\u0000\u0000\u01ed\u01eb\u0001\u0000\u0000\u0000\u01ed\u01ee\u0001\u0000\u0000\u0000\u01ee\u0202\u0001\u0000\u0000\u0000\u01ef\u01f0\u0005\u003b\u0000\u0000\u01f0\u01f2\u0003\u006a\u0035\u0000\u01f1\u01ef\u0001\u0000\u0000\u0000\u01f2\u01f3\u0001\u0000\u0000\u0000\u01f3\u01f1\u0001\u0000\u0000\u0000\u01f3\u01f4\u0001\u0000\u0000\u0000\u01f4\u0202\u0001\u0000\u0000\u0000\u01f5\u01f6\u0005\u003e\u0000\u0000\u01f6\u01f8\u0003\u0062\u0031\u0000\u01f7\u01f5\u0001\u0000\u0000\u0000\u01f8\u01f9\u0001\u0000\u0000\u0000\u01f9\u01f7\u0001\u0000\u0000\u0000\u01f9\u01fa\u0001\u0000\u0000\u0000\u01fa\u01fd\u0001\u0000\u0000\u0000\u01fb\u01fc\u0005\u003b\u0000\u0000\u01fc\u01fe\u0003\u006a\u0035\u0000\u01fd\u01fb\u0001\u0000\u0000\u0000\u01fe\u01ff\u0001\u0000\u0000\u0000\u01ff\u01fd\u0001\u0000\u0000\u0000\u01ff\u0200\u0001\u0000\u0000\u0000\u0200\u0202\u0001\u0000\u0000\u0000\u0201\u01eb\u0001\u0000\u0000\u0000\u0201\u01f1\u0001\u0000\u0000\u0000\u0201\u01f7\u0001\u0000\u0000\u0000\u0202\u0033\u0001\u0000\u0000\u0000\u0203\u0205\u0003\u0036\u001b\u0000\u0204\u0203\u0001\u0000\u0000\u0000\u0205\u0206\u0001\u0000\u0000\u0000\u0206\u0204\u0001\u0000\u0000\u0000\u0206\u0207\u0001\u0000\u0000\u0000\u0207\u0035\u0001\u0000\u0000\u0000\u0208\u020d\u0003\u0060\u0030\u0000\u0209\u020a\u0005\u0039\u0000\u0000\u020a\u020c\u0003\u0078\u003c\u0000\u020b\u0209\u0001\u0000\u0000\u0000\u020c\u020f\u0001\u0000\u0000\u0000\u020d\u020b\u0001\u0000\u0000\u0000\u020d\u020e\u0001\u0000\u0000\u0000\u020e\u0037\u0001\u0000\u0000\u0000\u020f\u020d\u0001\u0000\u0000\u0000\u0210\u0213\u0003\u006a\u0035\u0000\u0211\u0213\u0003\u0024\u0012\u0000\u0212\u0210\u0001\u0000\u0000\u0000\u0212\u0211\u0001\u0000\u0000\u0000\u0213\u0039\u0001\u0000\u0000\u0000\u0214\u0219\u0005\u0046\u0000\u0000\u0215\u0219\u0005\u0047\u0000\u0000\u0216\u0219\u0005\u0048\u0000\u0000\u0217\u0219\u0003\u003c\u001e\u0000\u0218\u0214\u0001\u0000\u0000\u0000\u0218\u0215\u0001\u0000\u0000\u0000\u0218\u0216\u0001\u0000\u0000\u0000\u0218\u0217\u0001\u0000\u0000\u0000\u0219\u003b\u0001\u0000\u0000\u0000\u021a\u021b\u0007\u0000\u0000\u0000\u021b\u003d\u0001\u0000\u0000\u0000\u021c\u021d\u0006\u001f\uffff\uffff\u0000\u021d\u0262\u0003\u003a\u001d\u0000\u021e\u0262\u0005\u0029\u0000\u0000\u021f\u0262\u0005\u002c\u0000\u0000\u0220\u0221\u0005\u0037\u0000\u0000\u0221\u0224\u0007\u0001\u0000\u0000\u0222\u0224\u0005\u0038\u0000\u0000\u0223\u0220\u0001\u0000\u0000\u0000\u0223\u0222\u0001\u0000\u0000\u0000\u0224\u0262\u0001\u0000\u0000\u0000\u0225\u0226\u0005\u003f\u0000\u0000\u0226\u0262\u0003\u0040\u0020\u0000\u0227\u0229\u0003\u0040\u0020\u0000\u0228\u022a\u0003\u0054\u002a\u0000\u0229\u0228\u0001\u0000\u0000\u0000\u0229\u022a\u0001\u0000\u0000\u0000\u022a\u0262\u0001\u0000\u0000\u0000\u022b\u022c\u0005\u0016\u0000\u0000\u022c\u022e\u0003\u0040\u0020\u0000\u022d\u022f\u0003\u0054\u002a\u0000\u022e\u022d\u0001\u0000\u0000\u0000\u022e\u022f\u0001\u0000\u0000\u0000\u022f\u0262\u0001\u0000\u0000\u0000\u0230\u0231\u0005\u0041\u0000\u0000\u0231\u0262\u0003\u0040\u0020\u0000\u0232\u0237\u0005\u0035\u0000\u0000\u0233\u0234\u0005\u003e\u0000\u0000\u0234\u0236\u0003\u0062\u0031\u0000\u0235\u0233\u0001\u0000\u0000\u0000\u0236\u0239\u0001\u0000\u0000\u0000\u0237\u0235\u0001\u0000\u0000\u0000\u0237\u0238\u0001\u0000\u0000\u0000\u0238\u023e\u0001\u0000\u0000\u0000\u0239\u0237\u0001\u0000\u0000\u0000\u023a\u023b\u0005\u003b\u0000\u0000\u023b\u023d\u0003\u006a\u0035\u0000\u023c\u023a\u0001\u0000\u0000\u0000\u023d\u0240\u0001\u0000\u0000\u0000\u023e\u023c\u0001\u0000\u0000\u0000\u023e\u023f\u0001\u0000\u0000\u0000\u023f\u0243\u0001\u0000\u0000\u0000\u0240\u023e\u0001\u0000\u0000\u0000\u0241\u0242\u0005\u000d\u0000\u0000\u0242\u0244\u0003\u002e\u0017\u0000\u0243\u0241\u0001\u0000\u0000\u0000\u0243\u0244\u0001\u0000\u0000\u0000\u0244\u0249\u0001\u0000\u0000\u0000\u0245\u0246\u0005\u000c\u0000\u0000\u0246\u0248\u0003\u0030\u0018\u0000\u0247\u0245\u0001\u0000\u0000\u0000\u0248\u024b\u0001\u0000\u0000\u0000\u0249\u0247\u0001\u0000\u0000\u0000\u0249\u024a\u0001\u0000\u0000\u0000\u024a\u024c\u0001\u0000\u0000\u0000\u024b\u0249\u0001\u0000\u0000\u0000\u024c\u0252\u0005\u0036\u0000\u0000\u024d\u0250\u0003\u002e\u0017\u0000\u024e\u0250\u0003\u0030\u0018\u0000\u024f\u024d\u0001\u0000\u0000\u0000\u024f\u024e\u0001\u0000\u0000\u0000\u0250\u0252\u0001\u0000\u0000\u0000\u0251\u0232\u0001\u0000\u0000\u0000\u0251\u024f\u0001\u0000\u0000\u0000\u0252\u0262\u0001\u0000\u0000\u0000\u0253\u0262\u0003\u004c\u0026\u0000\u0254\u0255\u0005\u0039\u0000\u0000\u0255\u0256\u0003\u0058\u002c\u0000\u0256\u0257\u0003\u003e\u001f\u000a\u0257\u0262\u0001\u0000\u0000\u0000\u0258\u0262\u0003\u0044\u0022\u0000\u0259\u0262\u0003\u0048\u0024\u0000\u025a\u0262\u0003\u0046\u0023\u0000\u025b\u0262\u0003\u001a\u000d\u0000\u025c\u0262\u0003\u0076\u003b\u0000\u025d\u025e\u0005\u0031\u0000\u0000\u025e\u025f\u0003\u003e\u001f\u0000\u025f\u0260\u0005\u0032\u0000\u0000\u0260\u0262\u0001\u0000\u0000\u0000\u0261\u021c\u0001\u0000\u0000\u0000\u0261\u021e\u0001\u0000\u0000\u0000\u0261\u021f\u0001\u0000\u0000\u0000\u0261\u0223\u0001\u0000\u0000\u0000\u0261\u0225\u0001\u0000\u0000\u0000\u0261\u0227\u0001\u0000\u0000\u0000\u0261\u022b\u0001\u0000\u0000\u0000\u0261\u0230\u0001\u0000\u0000\u0000\u0261\u0251\u0001\u0000\u0000\u0000\u0261\u0253\u0001\u0000\u0000\u0000\u0261\u0254\u0001\u0000\u0000\u0000\u0261\u0258\u0001\u0000\u0000\u0000\u0261\u0259\u0001\u0000\u0000\u0000\u0261\u025a\u0001\u0000\u0000\u0000\u0261\u025b\u0001\u0000\u0000\u0000\u0261\u025c\u0001\u0000\u0000\u0000\u0261\u025d\u0001\u0000\u0000\u0000\u0262\u02a9\u0001\u0000\u0000\u0000\u0263\u0264\u000a\u0012\u0000\u0000\u0264\u02a8\u0003\u0042\u0021\u0000\u0265\u0266\u000a\u0011\u0000\u0000\u0266\u0267\u0005\u003e\u0000\u0000\u0267\u02a8\u0003\u005a\u002d\u0000\u0268\u0269\u000a\u0010\u0000\u0000\u0269\u026a\u0005\u003b\u0000\u0000\u026a\u026c\u0003\u005a\u002d\u0000\u026b\u026d\u0003\u0054\u002a\u0000\u026c\u026b\u0001\u0000\u0000\u0000\u026c\u026d\u0001\u0000\u0000\u0000\u026d\u02a8\u0001\u0000\u0000\u0000\u026e\u026f\u000a\u000f\u0000\u0000\u026f\u0270\u0005\u0040\u0000\u0000\u0270\u02a8\u0003\u005a\u002d\u0000\u0271\u0272\u000a\u000e\u0000\u0000\u0272\u0273\u0005\u003c\u0000\u0000\u0273\u0275\u0003\u005a\u002d\u0000\u0274\u0276\u0003\u0054\u002a\u0000\u0275\u0274\u0001\u0000\u0000\u0000\u0275\u0276\u0001\u0000\u0000\u0000\u0276\u02a8\u0001\u0000\u0000\u0000\u0277\u0278\u000a\u000d\u0000\u0000\u0278\u02a8\u0003\u0056\u002b\u0000\u0279\u027a\u000a\u000c\u0000\u0000\u027a\u027b\u0005\u003d\u0000\u0000\u027b\u027d\u0003\u003e\u001f\u0000\u027c\u027e\u0003\u0056\u002b\u0000\u027d\u027c\u0001\u0000\u0000\u0000\u027d\u027e\u0001\u0000\u0000\u0000\u027e\u02a8\u0001\u0000\u0000\u0000\u027f\u0286\u000a\u000b\u0000\u0000\u0280\u0281\u0005\u003f\u0000\u0000\u0281\u0287\u0003\u0058\u002c\u0000\u0282\u0283\u0005\u0031\u0000\u0000\u0283\u0284\u0003\u0058\u002c\u0000\u0284\u0285\u0005\u0032\u0000\u0000\u0285\u0287\u0001\u0000\u0000\u0000\u0286\u0280\u0001\u0000\u0000\u0000\u0286\u0282\u0001\u0000\u0000\u0000\u0287\u02a8\u0001\u0000\u0000\u0000\u0288\u0291\u000a\u0009\u0000\u0000\u0289\u028a\u0003\u0058\u002c\u0000\u028a\u028b\u0003\u003e\u001f\u0000\u028b\u0292\u0001\u0000\u0000\u0000\u028c\u028d\u0005\u0031\u0000\u0000\u028d\u028e\u0003\u0058\u002c\u0000\u028e\u028f\u0003\u003e\u001f\u0000\u028f\u0290\u0005\u0032\u0000\u0000\u0290\u0292\u0001\u0000\u0000\u0000\u0291\u0289\u0001\u0000\u0000\u0000\u0291\u028c\u0001\u0000\u0000\u0000\u0292\u02a8\u0001\u0000\u0000\u0000\u0293\u029b\u000a\u0008\u0000\u0000\u0294\u0295\u0005\u001b\u0000\u0000\u0295\u029c\u0003\u0078\u003c\u0000\u0296\u0297\u0005\u0031\u0000\u0000\u0297\u0298\u0005\u001b\u0000\u0000\u0298\u0299\u0003\u0078\u003c\u0000\u0299\u029a\u0005\u0032\u0000\u0000\u029a\u029c\u0001\u0000\u0000\u0000\u029b\u0294\u0001\u0000\u0000\u0000\u029b\u0296\u0001\u0000\u0000\u0000\u029c\u02a8\u0001\u0000\u0000\u0000\u029d\u02a5\u000a\u0007\u0000\u0000\u029e\u029f\u0005\u0014\u0000\u0000\u029f\u02a6\u0003\u003e\u001f\u0000\u02a0\u02a1\u0005\u0031\u0000\u0000\u02a1\u02a2\u0005\u0014\u0000\u0000\u02a2\u02a3\u0003\u003e\u001f\u0000\u02a3\u02a4\u0005\u0032\u0000\u0000\u02a4\u02a6\u0001\u0000\u0000\u0000\u02a5\u029e\u0001\u0000\u0000\u0000\u02a5\u02a0\u0001\u0000\u0000\u0000\u02a6\u02a8\u0001\u0000\u0000\u0000\u02a7\u0263\u0001\u0000\u0000\u0000\u02a7\u0265\u0001\u0000\u0000\u0000\u02a7\u0268\u0001\u0000\u0000\u0000\u02a7\u026e\u0001\u0000\u0000\u0000\u02a7\u0271\u0001\u0000\u0000\u0000\u02a7\u0277\u0001\u0000\u0000\u0000\u02a7\u0279\u0001\u0000\u0000\u0000\u02a7\u027f\u0001\u0000\u0000\u0000\u02a7\u0288\u0001\u0000\u0000\u0000\u02a7\u0293\u0001\u0000\u0000\u0000\u02a7\u029d\u0001\u0000\u0000\u0000\u02a8\u02ab\u0001\u0000\u0000\u0000\u02a9\u02a7\u0001\u0000\u0000\u0000\u02a9\u02aa\u0001\u0000\u0000\u0000\u02aa\u003f\u0001\u0000\u0000\u0000\u02ab\u02a9\u0001\u0000\u0000\u0000\u02ac\u02ad\u0003\u0016\u000b\u0000\u02ad\u02ae\u0005\u0030\u0000\u0000\u02ae\u02b0\u0001\u0000\u0000\u0000\u02af\u02ac\u0001\u0000\u0000\u0000\u02af\u02b0\u0001\u0000\u0000\u0000\u02b0\u02b1\u0001\u0000\u0000\u0000\u02b1\u02b2\u0003\u005a\u002d\u0000\u02b2\u0041\u0001\u0000\u0000\u0000\u02b3\u02b4\u0005\u0031\u0000\u0000\u02b4\u02b5\u0005\u0039\u0000\u0000\u02b5\u02b6\u0003\u0078\u003c\u0000\u02b6\u02b7\u0005\u0032\u0000\u0000\u02b7\u0043\u0001\u0000\u0000\u0000\u02b8\u02b9\u0005\u0014\u0000\u0000\u02b9\u02ba\u0005\u0031\u0000\u0000\u02ba\u02bb\u0003\u003e\u001f\u0000\u02bb\u02bc\u0005\u0032\u0000\u0000\u02bc\u02bd\u0003\u003e\u001f\u0000\u02bd\u02be\u0005\u0015\u0000\u0000\u02be\u02bf\u0003\u003e\u001f\u0000\u02bf\u0045\u0001\u0000\u0000\u0000\u02c0\u02c1\u0005\u0017\u0000\u0000\u02c1\u02c2\u0003\u003e\u001f\u0000\u02c2\u02c3\u0005\u002e\u0000\u0000\u02c3\u02c4\u0003\u003e\u001f\u0000\u02c4\u02c5\u0003\u003e\u001f\u0000\u02c5\u0047\u0001\u0000\u0000\u0000\u02c6\u02c8\u0005\u001f\u0000\u0000\u02c7\u02c9\u0003\u004a\u0025\u0000\u02c8\u02c7\u0001\u0000\u0000\u0000\u02c9\u02ca\u0001\u0000\u0000\u0000\u02ca\u02c8\u0001\u0000\u0000\u0000\u02ca\u02cb\u0001\u0000\u0000\u0000\u02cb\u0049\u0001\u0000\u0000\u0000\u02cc\u02cf\u0003\u003e\u001f\u0000\u02cd\u02ce\u0005\u0019\u0000\u0000\u02ce\u02d0\u0003\u003e\u001f\u0000\u02cf\u02cd\u0001\u0000\u0000\u0000\u02cf\u02d0\u0001\u0000\u0000\u0000\u02d0\u02d1\u0001\u0000\u0000\u0000\u02d1\u02d2\u0005\u0037\u0000\u0000\u02d2\u02d3\u0003\u003e\u001f\u0000\u02d3\u004b\u0001\u0000\u0000\u0000\u02d4\u02d5\u0005\u0041\u0000\u0000\u02d5\u02d9\u0005\u0031\u0000\u0000\u02d6\u02d8\u0003\u003e\u001f\u0000\u02d7\u02d6\u0001\u0000\u0000\u0000\u02d8\u02db\u0001\u0000\u0000\u0000\u02d9\u02d7\u0001\u0000\u0000\u0000\u02d9\u02da\u0001\u0000\u0000\u0000\u02da\u02dc\u0001\u0000\u0000\u0000\u02db\u02d9\u0001\u0000\u0000\u0000\u02dc\u02dd\u0005\u0032\u0000\u0000\u02dd\u004d\u0001\u0000\u0000\u0000\u02de\u02df\u0005\u0044\u0000\u0000\u02df\u02e0\u0005\u002f\u0000\u0000\u02e0\u02e1\u0005\u0039\u0000\u0000\u02e1\u02f5\u0003\u0078\u003c\u0000\u02e2\u02e3\u0005\u0044\u0000\u0000\u02e3\u02e4\u0005\u0039\u0000\u0000\u02e4\u02f5\u0003\u0078\u003c\u0000\u02e5\u02e9\u0003\u003e\u001f\u0000\u02e6\u02e7\u0005\u0037\u0000\u0000\u02e7\u02ea\u0005\u0042\u0000\u0000\u02e8\u02ea\u0005\u0038\u0000\u0000\u02e9\u02e6\u0001\u0000\u0000\u0000\u02e9\u02e8\u0001\u0000\u0000\u0000\u02ea\u02eb\u0001\u0000\u0000\u0000\u02eb\u02ec\u0005\u0039\u0000\u0000\u02ec\u02ed\u0003\u0078\u003c\u0000\u02ed\u02f5\u0001\u0000\u0000\u0000\u02ee\u02ef\u0003\u003e\u001f\u0000\u02ef\u02f0\u0005\u0037\u0000\u0000\u02f0\u02f1\u0005\u0044\u0000\u0000\u02f1\u02f2\u0005\u0039\u0000\u0000\u02f2\u02f3\u0003\u0078\u003c\u0000\u02f3\u02f5\u0001\u0000\u0000\u0000\u02f4\u02de\u0001\u0000\u0000\u0000\u02f4\u02e2\u0001\u0000\u0000\u0000\u02f4\u02e5\u0001\u0000\u0000\u0000\u02f4\u02ee\u0001\u0000\u0000\u0000\u02f5\u004f\u0001\u0000\u0000\u0000\u02f6\u02f8\u0003\u004e\u0027\u0000\u02f7\u02f6\u0001\u0000\u0000\u0000\u02f8\u02f9\u0001\u0000\u0000\u0000\u02f9\u02f7\u0001\u0000\u0000\u0000\u02f9\u02fa\u0001\u0000\u0000\u0000\u02fa\u0051\u0001\u0000\u0000\u0000\u02fb\u02fc\u0005\u0044\u0000\u0000\u02fc\u02fe\u0005\u002e\u0000\u0000\u02fd\u02fb\u0001\u0000\u0000\u0000\u02fd\u02fe\u0001\u0000\u0000\u0000\u02fe\u0300\u0001\u0000\u0000\u0000\u02ff\u0301\u0005\u002f\u0000\u0000\u0300\u02ff\u0001\u0000\u0000\u0000\u0300\u0301\u0001\u0000\u0000\u0000\u0301\u0302\u0001\u0000\u0000\u0000\u0302\u0310\u0003\u003e\u001f\u0000\u0303\u0304\u0005\u0044\u0000\u0000\u0304\u0306\u0005\u002f\u0000\u0000\u0305\u0303\u0001\u0000\u0000\u0000\u0305\u0306\u0001\u0000\u0000\u0000\u0306\u0307\u0001\u0000\u0000\u0000\u0307\u030b\u0005\u0035\u0000\u0000\u0308\u030a\u0003\u003e\u001f\u0000\u0309\u0308\u0001\u0000\u0000\u0000\u030a\u030d\u0001\u0000\u0000\u0000\u030b\u0309\u0001\u0000\u0000\u0000\u030b\u030c\u0001\u0000\u0000\u0000\u030c\u030e\u0001\u0000\u0000\u0000\u030d\u030b\u0001\u0000\u0000\u0000\u030e\u0310\u0005\u0036\u0000\u0000\u030f\u02fd\u0001\u0000\u0000\u0000\u030f\u0305\u0001\u0000\u0000\u0000\u0310\u0053\u0001\u0000\u0000\u0000\u0311\u0319\u0005\u0031\u0000\u0000\u0312\u0314\u0003\u0078\u003c\u0000\u0313\u0312\u0001\u0000\u0000\u0000\u0314\u0317\u0001\u0000\u0000\u0000\u0315\u0313\u0001\u0000\u0000\u0000\u0315\u0316\u0001\u0000\u0000\u0000\u0316\u0318\u0001\u0000\u0000\u0000\u0317\u0315\u0001\u0000\u0000\u0000\u0318\u031a\u0005\u002d\u0000\u0000\u0319\u0315\u0001\u0000\u0000\u0000\u0319\u031a\u0001\u0000\u0000\u0000\u031a\u031e\u0001\u0000\u0000\u0000\u031b\u031d\u0003\u0052\u0029\u0000\u031c\u031b\u0001\u0000\u0000\u0000\u031d\u0320\u0001\u0000\u0000\u0000\u031e\u031c\u0001\u0000\u0000\u0000\u031e\u031f\u0001\u0000\u0000\u0000\u031f\u0321\u0001\u0000\u0000\u0000\u0320\u031e\u0001\u0000\u0000\u0000\u0321\u0334\u0005\u0032\u0000\u0000\u0322\u032a\u0005\u0035\u0000\u0000\u0323\u0325\u0003\u0078\u003c\u0000\u0324\u0323\u0001\u0000\u0000\u0000\u0325\u0328\u0001\u0000\u0000\u0000\u0326\u0324\u0001\u0000\u0000\u0000\u0326\u0327\u0001\u0000\u0000\u0000\u0327\u0329\u0001\u0000\u0000\u0000\u0328\u0326\u0001\u0000\u0000\u0000\u0329\u032b\u0005\u002d\u0000\u0000\u032a\u0326\u0001\u0000\u0000\u0000\u032a\u032b\u0001\u0000\u0000\u0000\u032b\u032f\u0001\u0000\u0000\u0000\u032c\u032e\u0003\u003e\u001f\u0000\u032d\u032c\u0001\u0000\u0000\u0000\u032e\u0331\u0001\u0000\u0000\u0000\u032f\u032d\u0001\u0000\u0000\u0000\u032f\u0330\u0001\u0000\u0000\u0000\u0330\u0332\u0001\u0000\u0000\u0000\u0331\u032f\u0001\u0000\u0000\u0000\u0332\u0334\u0005\u0036\u0000\u0000\u0333\u0311\u0001\u0000\u0000\u0000\u0333\u0322\u0001\u0000\u0000\u0000\u0334\u0055\u0001\u0000\u0000\u0000\u0335\u0336\u0005\u003b\u0000\u0000\u0336\u033a\u0005\u0031\u0000\u0000\u0337\u0339\u0003\u003e\u001f\u0000\u0338\u0337\u0001\u0000\u0000\u0000\u0339\u033c\u0001\u0000\u0000\u0000\u033a\u0338\u0001\u0000\u0000\u0000\u033a\u033b\u0001\u0000\u0000\u0000\u033b\u033d\u0001\u0000\u0000\u0000\u033c\u033a\u0001\u0000\u0000\u0000\u033d\u033e\u0005\u0032\u0000\u0000\u033e\u0057\u0001\u0000\u0000\u0000\u033f\u0344\u0005\u0045\u0000\u0000\u0340\u0341\u0003\u005a\u002d\u0000\u0341\u0342\u0005\u0043\u0000\u0000\u0342\u0344\u0001\u0000\u0000\u0000\u0343\u033f\u0001\u0000\u0000\u0000\u0343\u0340\u0001\u0000\u0000\u0000\u0344\u0059\u0001\u0000\u0000\u0000\u0345\u0349\u0005\u0044\u0000\u0000\u0346\u0349\u0003\u005c\u002e\u0000\u0347\u0349\u0003\u005e\u002f\u0000\u0348\u0345\u0001\u0000\u0000\u0000\u0348\u0346\u0001\u0000\u0000\u0000\u0348\u0347\u0001\u0000\u0000\u0000\u0349\u005b\u0001\u0000\u0000\u0000\u034a\u034b\u0005\u0033\u0000\u0000\u034b\u034c\u0005\u0045\u0000\u0000\u034c\u034d\u0005\u0034\u0000\u0000\u034d\u005d\u0001\u0000\u0000\u0000\u034e\u034f\u0005\u0033\u0000\u0000\u034f\u0350\u0005\u0039\u0000\u0000\u0350\u0351\u0005\u0045\u0000\u0000\u0351\u0352\u0005\u0034\u0000\u0000\u0352\u005f\u0001\u0000\u0000\u0000\u0353\u0358\u0005\u0044\u0000\u0000\u0354\u0355\u0005\u003f\u0000\u0000\u0355\u0356\u0005\u0044\u0000\u0000\u0356\u0358\u0005\u003f\u0000\u0000\u0357\u0353\u0001\u0000\u0000\u0000\u0357\u0354\u0001\u0000\u0000\u0000\u0358\u0061\u0001\u0000\u0000\u0000\u0359\u035d\u0003\u0066\u0033\u0000\u035a\u035d\u0003\u0064\u0032\u0000\u035b\u035d\u0003\u0068\u0034\u0000\u035c\u0359\u0001\u0000\u0000\u0000\u035c\u035a\u0001\u0000\u0000\u0000\u035c\u035b\u0001\u0000\u0000\u0000\u035d\u0063\u0001\u0000\u0000\u0000\u035e\u035f\u0005\u0031\u0000\u0000\u035f\u0360\u0005\u000f\u0000\u0000\u0360\u0362\u0005\u0032\u0000\u0000\u0361\u035e\u0001\u0000\u0000\u0000\u0361\u0362\u0001\u0000\u0000\u0000\u0362\u0363\u0001\u0000\u0000\u0000\u0363\u0364\u0005\u0044\u0000\u0000\u0364\u0365\u0003\u0078\u003c\u0000\u0365\u0065\u0001\u0000\u0000\u0000\u0366\u0367\u0005\u0031\u0000\u0000\u0367\u0368\u0005\u000f\u0000\u0000\u0368\u036a\u0005\u0032\u0000\u0000\u0369\u0366\u0001\u0000\u0000\u0000\u0369\u036a\u0001\u0000\u0000\u0000\u036a\u036b\u0001\u0000\u0000\u0000\u036b\u036c\u0005\u0044\u0000\u0000\u036c\u036d\u0003\u0078\u003c\u0000\u036d\u036e\u0005\u002e\u0000\u0000\u036e\u036f\u0003\u003e\u001f\u0000\u036f\u0067\u0001\u0000\u0000\u0000\u0370\u0371\u0005\u0031\u0000\u0000\u0371\u0372\u0005\u0008\u0000\u0000\u0372\u0373\u0005\u0032\u0000\u0000\u0373\u0374\u0005\u0044\u0000\u0000\u0374\u0378\u0003\u0078\u003c\u0000\u0375\u0376\u0005\u001c\u0000\u0000\u0376\u0377\u0005\u002e\u0000\u0000\u0377\u0379\u0003\u003e\u001f\u0000\u0378\u0375\u0001\u0000\u0000\u0000\u0378\u0379\u0001\u0000\u0000\u0000\u0379\u037e\u0001\u0000\u0000\u0000\u037a\u037b\u0005\u001d\u0000\u0000\u037b\u037c\u0005\u0044\u0000\u0000\u037c\u037d\u0005\u002e\u0000\u0000\u037d\u037f\u0003\u003e\u001f\u0000\u037e\u037a\u0001\u0000\u0000\u0000\u037e\u037f\u0001\u0000\u0000\u0000\u037f\u0069\u0001\u0000\u0000\u0000\u0380\u0384\u0003\u006c\u0036\u0000\u0381\u0383\u0003\u0070\u0038\u0000\u0382\u0381\u0001\u0000\u0000\u0000\u0383\u0386\u0001\u0000\u0000\u0000\u0384\u0382\u0001\u0000\u0000\u0000\u0384\u0385\u0001\u0000\u0000\u0000\u0385\u038f\u0001\u0000\u0000\u0000\u0386\u0384\u0001\u0000\u0000\u0000\u0387\u038b\u0003\u006e\u0037\u0000\u0388\u038a\u0003\u0070\u0038\u0000\u0389\u0388\u0001\u0000\u0000\u0000\u038a\u038d\u0001\u0000\u0000\u0000\u038b\u0389\u0001\u0000\u0000\u0000\u038b\u038c\u0001\u0000\u0000\u0000\u038c\u038f\u0001\u0000\u0000\u0000\u038d\u038b\u0001\u0000\u0000\u0000\u038e\u0380\u0001\u0000\u0000\u0000\u038e\u0387\u0001\u0000\u0000\u0000\u038f\u006b\u0001\u0000\u0000\u0000\u0390\u0392\u0003\u0098\u004c\u0000\u0391\u0390\u0001\u0000\u0000\u0000\u0391\u0392\u0001\u0000\u0000\u0000\u0392\u0393\u0001\u0000\u0000\u0000\u0393\u0395\u0003\u005a\u002d\u0000\u0394\u0396\u0003\u0034\u001a\u0000\u0395\u0394\u0001\u0000\u0000\u0000\u0395\u0396\u0001\u0000\u0000\u0000\u0396\u039b\u0001\u0000\u0000\u0000\u0397\u0398\u0005\u0031\u0000\u0000\u0398\u0399\u0003\u0050\u0028\u0000\u0399\u039a\u0005\u0032\u0000\u0000\u039a\u039c\u0001\u0000\u0000\u0000\u039b\u0397\u0001\u0000\u0000\u0000\u039b\u039c\u0001\u0000\u0000\u0000\u039c\u039d\u0001\u0000\u0000\u0000\u039d\u039e\u0003\u0078\u003c\u0000\u039e\u039f\u0005\u002e\u0000\u0000\u039f\u03a0\u0003\u003e\u001f\u0000\u03a0\u006d\u0001\u0000\u0000\u0000\u03a1\u03a3\u0003\u0098\u004c\u0000\u03a2\u03a1\u0001\u0000\u0000\u0000\u03a2\u03a3\u0001\u0000\u0000\u0000\u03a3\u03a4\u0001\u0000\u0000\u0000\u03a4\u03a6\u0003\u005a\u002d\u0000\u03a5\u03a7\u0003\u0034\u001a\u0000\u03a6\u03a5\u0001\u0000\u0000\u0000\u03a6\u03a7\u0001\u0000\u0000\u0000\u03a7\u03ac\u0001\u0000\u0000\u0000\u03a8\u03a9\u0005\u0031\u0000\u0000\u03a9\u03aa\u0003\u0050\u0028\u0000\u03aa\u03ab\u0005\u0032\u0000\u0000\u03ab\u03ad\u0001\u0000\u0000\u0000\u03ac\u03a8\u0001\u0000\u0000\u0000\u03ac\u03ad\u0001\u0000\u0000\u0000\u03ad\u03ae\u0001\u0000\u0000\u0000\u03ae\u03af\u0005\u0008\u0000\u0000\u03af\u03b1\u0003\u0078\u003c\u0000\u03b0\u03b2\u0003\u008a\u0045\u0000\u03b1\u03b0\u0001\u0000\u0000\u0000\u03b1\u03b2\u0001\u0000\u0000\u0000\u03b2\u006f\u0001\u0000\u0000\u0000\u03b3\u03b5\u0005\u0012\u0000\u0000\u03b4\u03b6\u0005\u0044\u0000\u0000\u03b5\u03b4\u0001\u0000\u0000\u0000\u03b5\u03b6\u0001\u0000\u0000\u0000\u03b6\u03b7\u0001\u0000\u0000\u0000\u03b7\u03b9\u0005\u0031\u0000\u0000\u03b8\u03ba\u0003\u0072\u0039\u0000\u03b9\u03b8\u0001\u0000\u0000\u0000\u03ba\u03bb\u0001\u0000\u0000\u0000\u03bb\u03b9\u0001\u0000\u0000\u0000\u03bb\u03bc\u0001\u0000\u0000\u0000\u03bc\u03bd\u0001\u0000\u0000\u0000\u03bd\u03be\u0005\u0032\u0000\u0000\u03be\u03cd\u0001\u0000\u0000\u0000\u03bf\u03c1\u0005\u0012\u0000\u0000\u03c0\u03c2\u0005\u0044\u0000\u0000\u03c1\u03c0\u0001\u0000\u0000\u0000\u03c1\u03c2\u0001\u0000\u0000\u0000\u03c2\u03c3\u0001\u0000\u0000\u0000\u03c3\u03c5\u0005\u0031\u0000\u0000\u03c4\u03c6\u0003\u0074\u003a\u0000\u03c5\u03c4\u0001\u0000\u0000\u0000\u03c6\u03c7\u0001\u0000\u0000\u0000\u03c7\u03c5\u0001\u0000\u0000\u0000\u03c7\u03c8\u0001\u0000\u0000\u0000\u03c8\u03c9\u0001\u0000\u0000\u0000\u03c9\u03ca\u0005\u0032\u0000\u0000\u03ca\u03cb\u0003\u003e\u001f\u0000\u03cb\u03cd\u0001\u0000\u0000\u0000\u03cc\u03b3\u0001\u0000\u0000\u0000\u03cc\u03bf\u0001\u0000\u0000\u0000\u03cd\u0071\u0001\u0000\u0000\u0000\u03ce\u03d1\u0003\u003e\u001f\u0000\u03cf\u03d0\u0005\u0039\u0000\u0000\u03d0\u03d2\u0003\u0078\u003c\u0000\u03d1\u03cf\u0001\u0000\u0000\u0000\u03d1\u03d2\u0001\u0000\u0000\u0000\u03d2\u03d6\u0001\u0000\u0000\u0000\u03d3\u03d4\u0005\u003a\u0000\u0000\u03d4\u03d6\u0005\u0044\u0000\u0000\u03d5\u03ce\u0001\u0000\u0000\u0000\u03d5\u03d3\u0001\u0000\u0000\u0000\u03d6\u0073\u0001\u0000\u0000\u0000\u03d7\u03db\u0005\u0038\u0000\u0000\u03d8\u03d9\u0005\u0037\u0000\u0000\u03d9\u03db\u0005\u0042\u0000\u0000\u03da\u03d7\u0001\u0000\u0000\u0000\u03da\u03d8\u0001\u0000\u0000\u0000\u03db\u03df\u0001\u0000\u0000\u0000\u03dc\u03dd\u0005\u003a\u0000\u0000\u03dd\u03df\u0005\u0044\u0000\u0000\u03de\u03da\u0001\u0000\u0000\u0000\u03de\u03dc\u0001\u0000\u0000\u0000\u03df\u0075\u0001\u0000\u0000\u0000\u03e0\u03e2\u0005\u0033\u0000\u0000\u03e1\u03e3\u0003\u0050\u0028\u0000\u03e2\u03e1\u0001\u0000\u0000\u0000\u03e2\u03e3\u0001\u0000\u0000\u0000\u03e3\u03e4\u0001\u0000\u0000\u0000\u03e4\u03e5\u0005\u0034\u0000\u0000\u03e5\u03e6\u0003\u003e\u001f\u0000\u03e6\u0077\u0001\u0000\u0000\u0000\u03e7\u03ef\u0003\u0082\u0041\u0000\u03e8\u03e9\u0005\u0031\u0000\u0000\u03e9\u03ea\u0003\u0082\u0041\u0000\u03ea\u03ec\u0005\u0032\u0000\u0000\u03eb\u03ed\u0005\u0042\u0000\u0000\u03ec\u03eb\u0001\u0000\u0000\u0000\u03ec\u03ed\u0001\u0000\u0000\u0000\u03ed\u03ef\u0001\u0000\u0000\u0000\u03ee\u03e7\u0001\u0000\u0000\u0000\u03ee\u03e8\u0001\u0000\u0000\u0000\u03ef\u03f5\u0001\u0000\u0000\u0000\u03f0\u03f2\u0003\u007a\u003d\u0000\u03f1\u03f3\u0005\u0042\u0000\u0000\u03f2\u03f1\u0001\u0000\u0000\u0000\u03f2\u03f3\u0001\u0000\u0000\u0000\u03f3\u03f5\u0001\u0000\u0000\u0000\u03f4\u03ee\u0001\u0000\u0000\u0000\u03f4\u03f0\u0001\u0000\u0000\u0000\u03f5\u0079\u0001\u0000\u0000\u0000\u03f6\u03f7\u0003\u0016\u000b\u0000\u03f7\u03f8\u0005\u0030\u0000\u0000\u03f8\u03fa\u0001\u0000\u0000\u0000\u03f9\u03f6\u0001\u0000\u0000\u0000\u03f9\u03fa\u0001\u0000\u0000\u0000\u03fa\u03fb\u0001\u0000\u0000\u0000\u03fb\u0404\u0003\u0060\u0030\u0000\u03fc\u03fe\u0005\u0031\u0000\u0000\u03fd\u03ff\u0003\u007c\u003e\u0000\u03fe\u03fd\u0001\u0000\u0000\u0000\u03ff\u0400\u0001\u0000\u0000\u0000\u0400\u03fe\u0001\u0000\u0000\u0000\u0400\u0401\u0001\u0000\u0000\u0000\u0401\u0402\u0001\u0000\u0000\u0000\u0402\u0403\u0005\u0032\u0000\u0000\u0403\u0405\u0001\u0000\u0000\u0000\u0404\u03fc\u0001\u0000\u0000\u0000\u0404\u0405\u0001\u0000\u0000\u0000\u0405\u0408\u0001\u0000\u0000\u0000\u0406\u0408\u0003\u007e\u003f\u0000\u0407\u03f9\u0001\u0000\u0000\u0000\u0407\u0406\u0001\u0000\u0000\u0000\u0408\u007b\u0001\u0000\u0000\u0000\u0409\u040e\u0003\u0078\u003c\u0000\u040a\u040e\u0003\u0084\u0042\u0000\u040b\u040e\u0003\u0086\u0043\u0000\u040c\u040e\u0003\u0088\u0044\u0000\u040d\u0409\u0001\u0000\u0000\u0000\u040d\u040a\u0001\u0000\u0000\u0000\u040d\u040b\u0001\u0000\u0000\u0000\u040d\u040c\u0001\u0000\u0000\u0000\u040e\u007d\u0001\u0000\u0000\u0000\u040f\u0410\u0007\u0002\u0000\u0000\u0410\u007f\u0001\u0000\u0000\u0000\u0411\u0413\u0003\u0078\u003c\u0000\u0412\u0414\u0005\u002f\u0000\u0000\u0413\u0412\u0001\u0000\u0000\u0000\u0413\u0414\u0001\u0000\u0000\u0000\u0414\u0081\u0001\u0000\u0000\u0000\u0415\u0419\u0005\u0031\u0000\u0000\u0416\u0418\u0003\u0080\u0040\u0000\u0417\u0416\u0001\u0000\u0000\u0000\u0418\u041b\u0001\u0000\u0000\u0000\u0419\u0417\u0001\u0000\u0000\u0000\u0419\u041a\u0001\u0000\u0000\u0000\u041a\u041c\u0001\u0000\u0000\u0000\u041b\u0419\u0001\u0000\u0000\u0000\u041c\u041d\u0005\u0032\u0000\u0000\u041d\u041e\u0005\u0037\u0000\u0000\u041e\u041f\u0003\u0078\u003c\u0000\u041f\u0083\u0001\u0000\u0000\u0000\u0420\u0421\u0005\u0033\u0000\u0000\u0421\u0422\u0005\u0039\u0000\u0000\u0422\u0423\u0003\u0078\u003c\u0000\u0423\u0424\u0005\u0034\u0000\u0000\u0424\u0085\u0001\u0000\u0000\u0000\u0425\u0426\u0005\u0033\u0000\u0000\u0426\u0427\u0003\u0078\u003c\u0000\u0427\u0428\u0005\u0039\u0000\u0000\u0428\u0429\u0005\u0034\u0000\u0000\u0429\u0087\u0001\u0000\u0000\u0000\u042a\u042b\u0005\u0033\u0000\u0000\u042b\u042c\u0005\u0042\u0000\u0000\u042c\u042d\u0005\u0034\u0000\u0000\u042d\u0089\u0001\u0000\u0000\u0000\u042e\u0432\u0005\u0035\u0000\u0000\u042f\u0431\u0003\u008c\u0046\u0000\u0430\u042f\u0001\u0000\u0000\u0000\u0431\u0434\u0001\u0000\u0000\u0000\u0432\u0430\u0001\u0000\u0000\u0000\u0432\u0433\u0001\u0000\u0000\u0000\u0433\u0435\u0001\u0000\u0000\u0000\u0434\u0432\u0001\u0000\u0000\u0000\u0435\u0438\u0005\u0036\u0000\u0000\u0436\u0438\u0005\u0049\u0000\u0000\u0437\u042e\u0001\u0000\u0000\u0000\u0437\u0436\u0001\u0000\u0000\u0000\u0438\u008b\u0001\u0000\u0000\u0000\u0439\u043a\u0003\u008e\u0047\u0000\u043a\u043b\u0005\u0049\u0000\u0000\u043b\u008d\u0001\u0000\u0000\u0000\u043c\u043d\u0005\u0044\u0000\u0000\u043d\u008f\u0001\u0000\u0000\u0000\u043e\u043f\u0005\u0018\u0000\u0000\u043f\u0444\u0003\u0060\u0030\u0000\u0440\u0441\u0005\u0031\u0000\u0000\u0441\u0442\u0003\u0034\u001a\u0000\u0442\u0443\u0005\u0032\u0000\u0000\u0443\u0445\u0001\u0000\u0000\u0000\u0444\u0440\u0001\u0000\u0000\u0000\u0444\u0445\u0001\u0000\u0000\u0000\u0445\u044f\u0001\u0000\u0000\u0000\u0446\u0447\u0005\u002e\u0000\u0000\u0447\u0450\u0003\u0078\u003c\u0000\u0448\u044a\u0005\u0008\u0000\u0000\u0449\u044b\u0003\u008a\u0045\u0000\u044a\u0449\u0001\u0000\u0000\u0000\u044a\u044b\u0001\u0000\u0000\u0000\u044b\u044d\u0001\u0000\u0000\u0000\u044c\u044e\u0003\u0092\u0049\u0000\u044d\u044c\u0001\u0000\u0000\u0000\u044d\u044e\u0001\u0000\u0000\u0000\u044e\u0450\u0001\u0000\u0000\u0000\u044f\u0446\u0001\u0000\u0000\u0000\u044f\u0448\u0001\u0000\u0000\u0000\u0450\u0091\u0001\u0000\u0000\u0000\u0451\u0452\u0005\u0013\u0000\u0000\u0452\u0457\u0005\u0035\u0000\u0000\u0453\u0454\u0005\u003b\u0000\u0000\u0454\u0456\u0003\u002a\u0015\u0000\u0455\u0453\u0001\u0000\u0000\u0000\u0456\u0459\u0001\u0000\u0000\u0000\u0457\u0455\u0001\u0000\u0000\u0000\u0457\u0458\u0001\u0000\u0000\u0000\u0458\u045e\u0001\u0000\u0000\u0000\u0459\u0457\u0001\u0000\u0000\u0000\u045a\u045b\u0005\u000c\u0000\u0000\u045b\u045d\u0003\u0030\u0018\u0000\u045c\u045a\u0001\u0000\u0000\u0000\u045d\u0460\u0001\u0000\u0000\u0000\u045e\u045c\u0001\u0000\u0000\u0000\u045e\u045f\u0001\u0000\u0000\u0000\u045f\u0461\u0001\u0000\u0000\u0000\u0460\u045e\u0001\u0000\u0000\u0000\u0461\u0462\u0005\u0036\u0000\u0000\u0462\u0093\u0001\u0000\u0000\u0000\u0463\u0464\u0005\u0005\u0000\u0000\u0464\u0465\u0005\u0044\u0000\u0000\u0465\u0466\u0005\u0031\u0000\u0000\u0466\u0467\u0003\u0050\u0028\u0000\u0467\u0468\u0005\u0032\u0000\u0000\u0468\u0095\u0001\u0000\u0000\u0000\u0469\u046a\u0003\u0016\u000b\u0000\u046a\u046b\u0005\u0030\u0000\u0000\u046b\u046d\u0001\u0000\u0000\u0000\u046c\u0469\u0001\u0000\u0000\u0000\u046c\u046d\u0001\u0000\u0000\u0000\u046d\u046e\u0001\u0000\u0000\u0000\u046e\u0470\u0005\u0044\u0000\u0000\u046f\u0471\u0003\u0054\u002a\u0000\u0470\u046f\u0001\u0000\u0000\u0000\u0470\u0471\u0001\u0000\u0000\u0000\u0471\u0097\u0001\u0000\u0000\u0000\u0472\u0476\u0005\u0033\u0000\u0000\u0473\u0475\u0003\u0096\u004b\u0000\u0474\u0473\u0001\u0000\u0000\u0000\u0475\u0478\u0001\u0000\u0000\u0000\u0476\u0474\u0001\u0000\u0000\u0000\u0476\u0477\u0001\u0000\u0000\u0000\u0477\u0479\u0001\u0000\u0000\u0000\u0478\u0476\u0001\u0000\u0000\u0000\u0479\u047a\u0005\u0034\u0000\u0000\u047a\u0099\u0001\u0000\u0000\u0000\u009f\u009b\u00a0\u00a6\u00a8\u00ae\u00b3\u00b6\u00b9\u00bf\u00c7\u00cb\u00d1\u00d3\u00e3\u00e9\u00f0\u00fb\u0104\u0116\u0119\u011c\u011f\u0127\u012e\u0134\u0138\u013e\u0144\u0147\u014f\u0157\u015e\u0163\u0168\u016e\u0171\u0174\u017c\u0180\u0185\u0189\u018f\u0193\u0197\u019c\u01a1\u01a8\u01ab\u01b1\u01b4\u01b7\u01bb\u01c1\u01cf\u01d2\u01d6\u01d9\u01db\u01e1\u01e5\u01e7\u01ed\u01f3\u01f9\u01ff\u0201\u0206\u020d\u0212\u0218\u0223\u0229\u022e\u0237\u023e\u0243\u0249\u024f\u0251\u0261\u026c\u0275\u027d\u0286\u0291\u029b\u02a5\u02a7\u02a9\u02af\u02ca\u02cf\u02d9\u02e9\u02f4\u02f9\u02fd\u0300\u0305\u030b\u030f\u0315\u0319\u031e\u0326\u032a\u032f\u0333\u033a\u0343\u0348\u0357\u035c\u0361\u0369\u0378\u037e\u0384\u038b\u038e\u0391\u0395\u039b\u03a2\u03a6\u03ac\u03b1\u03b5\u03bb\u03c1\u03c7\u03cc\u03d1\u03d5\u03da\u03de\u03e2\u03ec\u03ee\u03f2\u03f4\u03f9\u0400\u0404\u0407\u040d\u0413\u0419\u0432\u0437\u0444\u044a\u044d\u044f\u0457\u045e\u046c\u0470\u0476"

        private val ATN = ATNDeserializer().deserialize(serializedATN.toCharArray())

        init {
            decisionToDFA = Array(ATN.numberOfDecisions) {
                DFA(ATN.getDecisionState(it)!!, it)
            }
        }
    }

    private val WS = Tokens.WS.id
    private val COMMENT = Tokens.COMMENT.id
    private val LINE_COMMENT = Tokens.LINE_COMMENT.id
    private val ABSTRACT = Tokens.ABSTRACT.id
    private val ANNOTATION = Tokens.ANNOTATION.id
    private val CLASS = Tokens.CLASS.id
    private val DO = Tokens.DO.id
    private val FOREIGN = Tokens.FOREIGN.id
    private val NAMESPACE = Tokens.NAMESPACE.id
    private val INTERNAL = Tokens.INTERNAL.id
    private val IMPORT = Tokens.IMPORT.id
    private val IMPL = Tokens.IMPL.id
    private val INHERIT = Tokens.INHERIT.id
    private val RETURN = Tokens.RETURN.id
    private val MUTABLE = Tokens.MUTABLE.id
    private val INTERFACE = Tokens.INTERFACE.id
    private val DATA = Tokens.DATA.id
    private val INVERSE = Tokens.INVERSE.id
    private val EXPECT = Tokens.EXPECT.id
    private val IF = Tokens.IF.id
    private val ELSE = Tokens.ELSE.id
    private val NEW = Tokens.NEW.id
    private val LET = Tokens.LET.id
    private val TYPEALIAS = Tokens.TYPEALIAS.id
    private val WHERE = Tokens.WHERE.id
    private val FROM = Tokens.FROM.id
    private val IS = Tokens.IS.id
    private val GET = Tokens.GET.id
    private val SET = Tokens.SET.id
    private val REMAIN = Tokens.REMAIN.id
    private val MATCH = Tokens.MATCH.id
    private val INT = Tokens.INT.id
    private val LONG = Tokens.LONG.id
    private val DOUBLE = Tokens.DOUBLE.id
    private val FLOAT = Tokens.FLOAT.id
    private val BYTE = Tokens.BYTE.id
    private val CHAR = Tokens.CHAR.id
    private val STRING = Tokens.STRING.id
    private val BOOLEAN = Tokens.BOOLEAN.id
    private val UNIT = Tokens.UNIT.id
    private val NULLKEYWORD = Tokens.NULLKEYWORD.id
    private val TRUE = Tokens.TRUE.id
    private val FALSE = Tokens.FALSE.id
    private val THIS = Tokens.THIS.id
    private val PIPE = Tokens.PIPE.id
    private val ASSGIN = Tokens.ASSGIN.id
    private val ELLIPSIS = Tokens.ELLIPSIS.id
    private val DOT = Tokens.DOT.id
    private val LPAREN = Tokens.LPAREN.id
    private val RPAREN = Tokens.RPAREN.id
    private val LSQUARE = Tokens.LSQUARE.id
    private val RSQUARE = Tokens.RSQUARE.id
    private val LBRACE = Tokens.LBRACE.id
    private val RBRACE = Tokens.RBRACE.id
    private val ARROW = Tokens.ARROW.id
    private val ARROWQM = Tokens.ARROWQM.id
    private val TILDE = Tokens.TILDE.id
    private val As = Tokens.As.id
    private val COLON = Tokens.COLON.id
    private val DOUBLECOLON = Tokens.DOUBLECOLON.id
    private val TRIPLECOLON = Tokens.TRIPLECOLON.id
    private val COLONSHARP = Tokens.COLONSHARP.id
    private val QUOTE = Tokens.QUOTE.id
    private val COLONQUOTE = Tokens.COLONQUOTE.id
    private val SHARP = Tokens.SHARP.id
    private val QM = Tokens.QM.id
    private val EM = Tokens.EM.id
    private val ID = Tokens.ID.id
    private val OPID = Tokens.OPID.id
    private val Integer = Tokens.Integer.id
    private val Double = Tokens.Double.id
    private val String = Tokens.String.id
    private val RawString = Tokens.RawString.id

    /* Named actions */

    init {
        interpreter = ParserATNSimulator(this, ATN, decisionToDFA, sharedContextCache)
    }

    /* Funcs */
    @Suppress("FunctionName")
    public open class FileContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_file.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()

        public fun findNamespace(): NamespaceContext? = getRuleContext(NamespaceContext::class, 0)
        public fun findImportEx(): List<ImportExContext> = getRuleContexts(ImportExContext::class)
        public fun findImportEx(i: Int): ImportExContext? = getRuleContext(ImportExContext::class, i)
        public fun findFileCompo(): List<FileCompoContext> = getRuleContexts(FileCompoContext::class)
        public fun findFileCompo(i: Int): FileCompoContext? = getRuleContext(FileCompoContext::class, i)
        public fun findAnnotationDef(): List<AnnotationDefContext> = getRuleContexts(AnnotationDefContext::class)
        public fun findAnnotationDef(i: Int): AnnotationDefContext? = getRuleContext(AnnotationDefContext::class, i)
        public fun findTypeAlias(): List<TypeAliasContext> = getRuleContexts(TypeAliasContext::class)
        public fun findTypeAlias(i: Int): TypeAliasContext? = getRuleContext(TypeAliasContext::class, i)

        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterFile(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitFile(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitFile(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun file(): FileContext {
        var _localctx = FileContext(context, state)
        enterRule(_localctx, 0, Rules.RULE_file.id)
        var _la: Int

        try {
            enterOuterAlt(_localctx, 1)
            scoped {
                this.state = 155
                errorHandler.sync(this)
                _la = _input!!.LA(1)

                if (_la == NAMESPACE) {
                    scoped {
                        this.state = 154
                        namespace()
                    }
                }
                this.state = 160
                errorHandler.sync(this)
                _la = _input!!.LA(1)

                while (_la == IMPORT) {
                    scoped {
                        scoped {
                            this.state = 157
                            importEx()
                        }
                    }
                    this.state = 162
                    errorHandler.sync(this)
                    _la = _input!!.LA(1)
                }
                this.state = 168
                errorHandler.sync(this)
                _la = _input!!.LA(1)

                while ((((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and 2251799830659184L) != 0L) || _la == SHARP || _la == ID) {
                    scoped {
                        this.state = 166
                        errorHandler.sync(this)

                        when (_input!!.LA(1)) {
                            ABSTRACT , CLASS , INTERFACE , DATA , LSQUARE , SHARP , ID  ->  /*LL1AltBlock*/ {
                                scoped {
                                    this.state = 163
                                    fileCompo()
                                }
                            }ANNOTATION  ->  /*LL1AltBlock*/ {
                                scoped {
                                    this.state = 164
                                    annotationDef()
                                }
                            }TYPEALIAS  ->  /*LL1AltBlock*/ {
                                scoped {
                                    this.state = 165
                                    typeAlias()
                                }
                            }
                            else -> throw NoViableAltException(this)
                        }
                    }
                    this.state = 170
                    errorHandler.sync(this)
                    _la = _input!!.LA(1)
                }
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class FileCompoContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_fileCompo.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()

        public fun findDefinition(): DefinitionContext? = getRuleContext(DefinitionContext::class, 0)
        public fun SHARP(): TerminalNode? = getToken(Tokens.SHARP.id, 0)
        public fun findField(): FieldContext? = getRuleContext(FieldContext::class, 0)

        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterFileCompo(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitFileCompo(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitFileCompo(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun fileCompo(): FileCompoContext {
        var _localctx = FileCompoContext(context, state)
        enterRule(_localctx, 2, Rules.RULE_fileCompo.id)

        try {
            this.state = 174
            errorHandler.sync(this)

            when (_input!!.LA(1)) {
                ABSTRACT , CLASS , INTERFACE , DATA , LSQUARE , ID  ->  /*LL1AltBlock*/ {
                    enterOuterAlt(_localctx, 1)
                    scoped {
                        this.state = 171
                        definition()
                    }
                }SHARP  ->  /*LL1AltBlock*/ {
                    enterOuterAlt(_localctx, 2)
                    scoped {
                        this.state = 172
                        match(SHARP)
                        this.state = 173
                        field()
                    }
                }
                else -> throw NoViableAltException(this)
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class ImportExContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_importEx.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()

        public fun IMPORT(): TerminalNode? = getToken(Tokens.IMPORT.id, 0)
        public fun findPackage_(): Package_Context? = getRuleContext(Package_Context::class, 0)
        public fun findImportNest(): ImportNestContext? = getRuleContext(ImportNestContext::class, 0)
        public fun findImportPath(): ImportPathContext? = getRuleContext(ImportPathContext::class, 0)
        public fun findImportBody(): ImportBodyContext? = getRuleContext(ImportBodyContext::class, 0)

        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterImportEx(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitImportEx(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitImportEx(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun importEx(): ImportExContext {
        var _localctx = ImportExContext(context, state)
        enterRule(_localctx, 4, Rules.RULE_importEx.id)
        var _la: Int

        try {
            enterOuterAlt(_localctx, 1)
            scoped {
                this.state = 176
                match(IMPORT)
                this.state = 177
                package_()
                this.state = 179
                errorHandler.sync(this)

                when (interpreter!!.adaptivePredict(_input!!, 5, context)) {
                    1 -> scoped {
                    this.state = 178
                    importNest()
                }
                }
                this.state = 182
                errorHandler.sync(this)
                _la = _input!!.LA(1)

                if (_la == LPAREN) {
                    scoped {
                        this.state = 181
                        importPath()
                    }
                }
                this.state = 185
                errorHandler.sync(this)
                _la = _input!!.LA(1)

                if (_la == LBRACE) {
                    scoped {
                        this.state = 184
                        importBody()
                    }
                }
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class ImportBodyContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_importBody.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()

        public fun LBRACE(): TerminalNode? = getToken(Tokens.LBRACE.id, 0)
        public fun RBRACE(): TerminalNode? = getToken(Tokens.RBRACE.id, 0)
        public fun findImportCompo(): List<ImportCompoContext> = getRuleContexts(ImportCompoContext::class)
        public fun findImportCompo(i: Int): ImportCompoContext? = getRuleContext(ImportCompoContext::class, i)

        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterImportBody(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitImportBody(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitImportBody(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun importBody(): ImportBodyContext {
        var _localctx = ImportBodyContext(context, state)
        enterRule(_localctx, 6, Rules.RULE_importBody.id)
        var _la: Int

        try {
            enterOuterAlt(_localctx, 1)
            scoped {
                this.state = 187
                match(LBRACE)
                this.state = 191
                errorHandler.sync(this)
                _la = _input!!.LA(1)

                while (((((_la - 6)) and 0x3f.inv()) == 0 && ((1L shl (_la - 6)) and 4611721202799476737L) != 0L)) {
                    scoped {
                        scoped {
                            this.state = 188
                            importCompo()
                        }
                    }
                    this.state = 193
                    errorHandler.sync(this)
                    _la = _input!!.LA(1)
                }
                this.state = 194
                match(RBRACE)
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class ImportCompoContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_importCompo.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()

        public fun findCommonIdentifier(): CommonIdentifierContext? = getRuleContext(CommonIdentifierContext::class, 0)
        public fun SHARP(): TerminalNode? = getToken(Tokens.SHARP.id, 0)
        public fun findImportDefAlias(): ImportDefAliasContext? = getRuleContext(ImportDefAliasContext::class, 0)
        public fun As(): TerminalNode? = getToken(Tokens.As.id, 0)
        public fun findImportType(): ImportTypeContext? = getRuleContext(ImportTypeContext::class, 0)
        public fun CLASS(): TerminalNode? = getToken(Tokens.CLASS.id, 0)
        public fun findCommonClassIdentifier(): CommonClassIdentifierContext? = getRuleContext(CommonClassIdentifierContext::class, 0)
        public fun findImportClassAlias(): ImportClassAliasContext? = getRuleContext(ImportClassAliasContext::class, 0)

        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterImportCompo(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitImportCompo(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitImportCompo(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun importCompo(): ImportCompoContext {
        var _localctx = ImportCompoContext(context, state)
        enterRule(_localctx, 8, Rules.RULE_importCompo.id)
        var _la: Int

        try {
            this.state = 211
            errorHandler.sync(this)

            when (_input!!.LA(1)) {
                LSQUARE , ID  ->  /*LL1AltBlock*/ {
                    enterOuterAlt(_localctx, 1)
                    scoped {
                        this.state = 196
                        commonIdentifier()
                        this.state = 199
                        errorHandler.sync(this)
                        _la = _input!!.LA(1)

                        if (_la == SHARP) {
                            scoped {
                                this.state = 197
                                match(SHARP)
                                this.state = 198
                                importDefAlias()
                            }
                        }
                        this.state = 203
                        errorHandler.sync(this)
                        _la = _input!!.LA(1)

                        if (_la == As) {
                            scoped {
                                this.state = 201
                                match(As)
                                this.state = 202
                                importType()
                            }
                        }
                    }
                }CLASS  ->  /*LL1AltBlock*/ {
                    enterOuterAlt(_localctx, 2)
                    scoped {
                        this.state = 205
                        match(CLASS)
                        this.state = 206
                        commonClassIdentifier()
                        this.state = 209
                        errorHandler.sync(this)
                        _la = _input!!.LA(1)

                        if (_la == SHARP) {
                            scoped {
                                this.state = 207
                                match(SHARP)
                                this.state = 208
                                importClassAlias()
                            }
                        }
                    }
                }
                else -> throw NoViableAltException(this)
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class ImportDefAliasContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_importDefAlias.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()

        public fun findCommonIdentifier(): CommonIdentifierContext? = getRuleContext(CommonIdentifierContext::class, 0)

        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterImportDefAlias(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitImportDefAlias(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitImportDefAlias(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun importDefAlias(): ImportDefAliasContext {
        var _localctx = ImportDefAliasContext(context, state)
        enterRule(_localctx, 10, Rules.RULE_importDefAlias.id)

        try {
            enterOuterAlt(_localctx, 1)
            scoped {
                this.state = 213
                commonIdentifier()
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class ImportClassAliasContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_importClassAlias.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()

        public fun findCommonClassIdentifier(): CommonClassIdentifierContext? = getRuleContext(CommonClassIdentifierContext::class, 0)

        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterImportClassAlias(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitImportClassAlias(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitImportClassAlias(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun importClassAlias(): ImportClassAliasContext {
        var _localctx = ImportClassAliasContext(context, state)
        enterRule(_localctx, 12, Rules.RULE_importClassAlias.id)

        try {
            enterOuterAlt(_localctx, 1)
            scoped {
                this.state = 215
                commonClassIdentifier()
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class ImportTypeContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_importType.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()

        public fun findTypeEx(): TypeExContext? = getRuleContext(TypeExContext::class, 0)

        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterImportType(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitImportType(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitImportType(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun importType(): ImportTypeContext {
        var _localctx = ImportTypeContext(context, state)
        enterRule(_localctx, 14, Rules.RULE_importType.id)

        try {
            enterOuterAlt(_localctx, 1)
            scoped {
                this.state = 217
                typeEx()
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class ImportPathContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_importPath.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()

        public fun LPAREN(): TerminalNode? = getToken(Tokens.LPAREN.id, 0)
        public fun FROM(): TerminalNode? = getToken(Tokens.FROM.id, 0)
        public fun RawString(): TerminalNode? = getToken(Tokens.RawString.id, 0)
        public fun RPAREN(): TerminalNode? = getToken(Tokens.RPAREN.id, 0)

        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterImportPath(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitImportPath(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitImportPath(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun importPath(): ImportPathContext {
        var _localctx = ImportPathContext(context, state)
        enterRule(_localctx, 16, Rules.RULE_importPath.id)

        try {
            enterOuterAlt(_localctx, 1)
            scoped {
                this.state = 219
                match(LPAREN)
                this.state = 220
                match(FROM)
                this.state = 221
                match(RawString)
                this.state = 222
                match(RPAREN)
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class ImportNestContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_importNest.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()

        public fun SHARP(): TerminalNode? = getToken(Tokens.SHARP.id, 0)
        public fun ID(): TerminalNode? = getToken(Tokens.ID.id, 0)
        public fun EM(): TerminalNode? = getToken(Tokens.EM.id, 0)

        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterImportNest(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitImportNest(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitImportNest(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun importNest(): ImportNestContext {
        var _localctx = ImportNestContext(context, state)
        enterRule(_localctx, 18, Rules.RULE_importNest.id)

        try {
            this.state = 227
            errorHandler.sync(this)

            when (_input!!.LA(1)) {
                SHARP  ->  /*LL1AltBlock*/ {
                    enterOuterAlt(_localctx, 1)
                    scoped {
                        this.state = 224
                        match(SHARP)
                        this.state = 225
                        match(ID)
                    }
                }EM  ->  /*LL1AltBlock*/ {
                    enterOuterAlt(_localctx, 2)
                    scoped {
                        this.state = 226
                        match(EM)
                    }
                }
                else -> throw NoViableAltException(this)
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class PackagePieceContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_packagePiece.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()

        public fun ID(): TerminalNode? = getToken(Tokens.ID.id, 0)
        public fun LBRACE(): TerminalNode? = getToken(Tokens.LBRACE.id, 0)
        public fun RBRACE(): TerminalNode? = getToken(Tokens.RBRACE.id, 0)

        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterPackagePiece(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitPackagePiece(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitPackagePiece(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun packagePiece(): PackagePieceContext {
        var _localctx = PackagePieceContext(context, state)
        enterRule(_localctx, 20, Rules.RULE_packagePiece.id)

        try {
            this.state = 233
            errorHandler.sync(this)

            when (_input!!.LA(1)) {
                ID  ->  /*LL1AltBlock*/ {
                    enterOuterAlt(_localctx, 1)
                    scoped {
                        this.state = 229
                        match(ID)
                    }
                }LBRACE  ->  /*LL1AltBlock*/ {
                    enterOuterAlt(_localctx, 2)
                    scoped {
                        this.state = 230
                        match(LBRACE)
                        this.state = 231
                        match(ID)
                        this.state = 232
                        match(RBRACE)
                    }
                }
                else -> throw NoViableAltException(this)
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class Package_Context : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_package_.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()

        public fun findPackagePiece(): List<PackagePieceContext> = getRuleContexts(PackagePieceContext::class)
        public fun findPackagePiece(i: Int): PackagePieceContext? = getRuleContext(PackagePieceContext::class, i)
        public fun DOT(): List<TerminalNode> = getTokens(Tokens.DOT.id)
        public fun DOT(i: Int): TerminalNode = getToken(Tokens.DOT.id, i)!!

        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterPackage_(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitPackage_(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitPackage_(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun package_(): Package_Context {
        var _localctx = Package_Context(context, state)
        enterRule(_localctx, 22, Rules.RULE_package_.id)

        try {
            var _alt: Int
            enterOuterAlt(_localctx, 1)
            scoped {
                this.state = 235
                packagePiece()
                this.state = 240
                errorHandler.sync(this)
                _alt = interpreter!!.adaptivePredict(_input!!,15,context)

                while (_alt != 2 && _alt != INVALID_ALT_NUMBER) {
                    if (_alt == 1 ) {
                        scoped {
                            scoped {
                                this.state = 236
                                match(DOT)
                                this.state = 237
                                packagePiece()
                            }
                        } 
                    }

                    this.state = 242
                    errorHandler.sync(this)
                    _alt = interpreter!!.adaptivePredict(_input!!, 15, context)
                }
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class NamespaceContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_namespace.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()

        public fun NAMESPACE(): TerminalNode? = getToken(Tokens.NAMESPACE.id, 0)
        public fun findPackage_(): Package_Context? = getRuleContext(Package_Context::class, 0)

        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterNamespace(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitNamespace(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitNamespace(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun namespace(): NamespaceContext {
        var _localctx = NamespaceContext(context, state)
        enterRule(_localctx, 24, Rules.RULE_namespace.id)

        try {
            enterOuterAlt(_localctx, 1)
            scoped {
                this.state = 243
                match(NAMESPACE)
                this.state = 244
                package_()
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class DoBlockContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_doBlock.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()

        public fun DO(): TerminalNode? = getToken(Tokens.DO.id, 0)
        public fun LBRACE(): TerminalNode? = getToken(Tokens.LBRACE.id, 0)
        public fun RBRACE(): TerminalNode? = getToken(Tokens.RBRACE.id, 0)
        public fun findCompo(): List<CompoContext> = getRuleContexts(CompoContext::class)
        public fun findCompo(i: Int): CompoContext? = getRuleContext(CompoContext::class, i)

        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterDoBlock(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitDoBlock(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitDoBlock(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun doBlock(): DoBlockContext {
        var _localctx = DoBlockContext(context, state)
        enterRule(_localctx, 26, Rules.RULE_doBlock.id)
        var _la: Int

        try {
            enterOuterAlt(_localctx, 1)
            scoped {
                this.state = 246
                match(DO)
                this.state = 247
                match(LBRACE)
                this.state = 251
                errorHandler.sync(this)
                _la = _input!!.LA(1)

                while ((((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and -8959315520116461440L) != 0L) || ((((_la - 65)) and 0x3f.inv()) == 0 && ((1L shl (_la - 65)) and 233L) != 0L)) {
                    scoped {
                        scoped {
                            this.state = 248
                            compo()
                        }
                    }
                    this.state = 253
                    errorHandler.sync(this)
                    _la = _input!!.LA(1)
                }
                this.state = 254
                match(RBRACE)
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class CompoContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_compo.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()

        public fun findFieldAssign(): FieldAssignContext? = getRuleContext(FieldAssignContext::class, 0)
        public fun findRemainLet_binding(): RemainLet_bindingContext? = getRuleContext(RemainLet_bindingContext::class, 0)
        public fun findValue(): ValueContext? = getRuleContext(ValueContext::class, 0)
        public fun findReturning(): ReturningContext? = getRuleContext(ReturningContext::class, 0)

        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterCompo(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitCompo(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitCompo(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun compo(): CompoContext {
        var _localctx = CompoContext(context, state)
        enterRule(_localctx, 28, Rules.RULE_compo.id)

        try {
            this.state = 260
            errorHandler.sync(this)

            when (interpreter!!.adaptivePredict(_input!!, 17, context)) {
                1 -> {
                    enterOuterAlt(_localctx, 1)
                    scoped {
                        this.state = 256
                        fieldAssign()
                    }
                }2 -> {
                    enterOuterAlt(_localctx, 2)
                    scoped {
                        this.state = 257
                        remainLet_binding()
                    }
                }3 -> {
                    enterOuterAlt(_localctx, 3)
                    scoped {
                        this.state = 258
                        value(0)
                    }
                }4 -> {
                    enterOuterAlt(_localctx, 4)
                    scoped {
                        this.state = 259
                        returning()
                    }
                }
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class RemainLet_bindingContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_remainLet_binding.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()

        public fun REMAIN(): TerminalNode? = getToken(Tokens.REMAIN.id, 0)
        public fun findLet_binding(): Let_bindingContext? = getRuleContext(Let_bindingContext::class, 0)

        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterRemainLet_binding(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitRemainLet_binding(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitRemainLet_binding(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun remainLet_binding(): RemainLet_bindingContext {
        var _localctx = RemainLet_bindingContext(context, state)
        enterRule(_localctx, 30, Rules.RULE_remainLet_binding.id)

        try {
            enterOuterAlt(_localctx, 1)
            scoped {
                this.state = 262
                match(REMAIN)
                this.state = 263
                let_binding()
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class ReturningContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_returning.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()

        public fun RETURN(): TerminalNode? = getToken(Tokens.RETURN.id, 0)
        public fun findValue(): ValueContext? = getRuleContext(ValueContext::class, 0)

        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterReturning(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitReturning(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitReturning(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun returning(): ReturningContext {
        var _localctx = ReturningContext(context, state)
        enterRule(_localctx, 32, Rules.RULE_returning.id)

        try {
            enterOuterAlt(_localctx, 1)
            scoped {
                this.state = 265
                match(RETURN)
                this.state = 266
                value(0)
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class FieldAssignContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_fieldAssign.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()


        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

     
        public constructor() : super()

        public fun copyFrom(ctx: FieldAssignContext) {
            super.copyFrom(ctx)
        }

    }

    public open class ObjectFieldAssignContext : FieldAssignContext {
        public fun findValue(): List<ValueContext> = getRuleContexts(ValueContext::class)
        public fun findValue(i: Int): ValueContext? = getRuleContext(ValueContext::class, i)
        public fun COLONSHARP(): TerminalNode? = getToken(Tokens.COLONSHARP.id, 0)
        public fun ID(): TerminalNode? = getToken(Tokens.ID.id, 0)
        public fun ASSGIN(): TerminalNode? = getToken(Tokens.ASSGIN.id, 0)

        public constructor(ctx: FieldAssignContext) {
            copyFrom(ctx)
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterObjectFieldAssign(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitObjectFieldAssign(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitObjectFieldAssign(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }

    public open class GlobalFieldAssignContext : FieldAssignContext {
        public fun SHARP(): TerminalNode? = getToken(Tokens.SHARP.id, 0)
        public fun ID(): TerminalNode? = getToken(Tokens.ID.id, 0)
        public fun ASSGIN(): TerminalNode? = getToken(Tokens.ASSGIN.id, 0)
        public fun findValue(): ValueContext? = getRuleContext(ValueContext::class, 0)

        public constructor(ctx: FieldAssignContext) {
            copyFrom(ctx)
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterGlobalFieldAssign(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitGlobalFieldAssign(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitGlobalFieldAssign(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun fieldAssign(): FieldAssignContext {
        var _localctx = FieldAssignContext(context, state)
        enterRule(_localctx, 34, Rules.RULE_fieldAssign.id)

        try {
            this.state = 278
            errorHandler.sync(this)

            when (interpreter!!.adaptivePredict(_input!!, 18, context)) {
                1 -> {
                    _localctx = GlobalFieldAssignContext(_localctx)
                    enterOuterAlt(_localctx, 1)
                    scoped {
                        this.state = 268
                        match(SHARP)
                        this.state = 269
                        match(ID)
                        this.state = 270
                        match(ASSGIN)
                        this.state = 271
                        value(0)
                    }
                }2 -> {
                    _localctx = ObjectFieldAssignContext(_localctx)
                    enterOuterAlt(_localctx, 2)
                    scoped {
                        this.state = 272
                        value(0)
                        this.state = 273
                        match(COLONSHARP)
                        this.state = 274
                        match(ID)
                        this.state = 275
                        match(ASSGIN)
                        this.state = 276
                        value(0)
                    }
                }
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class Class_Context : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_class_.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()


        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

     
        public constructor() : super()

        public fun copyFrom(ctx: Class_Context) {
            super.copyFrom(ctx)
        }

    }

    public open class JustInterfaceContext : Class_Context {
        public fun CLASS(): TerminalNode? = getToken(Tokens.CLASS.id, 0)
        public fun findCommonClassIdentifier(): CommonClassIdentifierContext? = getRuleContext(CommonClassIdentifierContext::class, 0)
        public fun LBRACE(): TerminalNode? = getToken(Tokens.LBRACE.id, 0)
        public fun RBRACE(): TerminalNode? = getToken(Tokens.RBRACE.id, 0)
        public fun findAnnotationBlock(): AnnotationBlockContext? = getRuleContext(AnnotationBlockContext::class, 0)
        public fun ABSTRACT(): TerminalNode? = getToken(Tokens.ABSTRACT.id, 0)
        public fun INTERFACE(): TerminalNode? = getToken(Tokens.INTERFACE.id, 0)
        public fun LPAREN(): TerminalNode? = getToken(Tokens.LPAREN.id, 0)
        public fun findTypeParam(): TypeParamContext? = getRuleContext(TypeParamContext::class, 0)
        public fun RPAREN(): TerminalNode? = getToken(Tokens.RPAREN.id, 0)
        public fun COLONSHARP(): List<TerminalNode> = getTokens(Tokens.COLONSHARP.id)
        public fun COLONSHARP(i: Int): TerminalNode = getToken(Tokens.COLONSHARP.id, i)!!
        public fun findFieldInInterface(): List<FieldInInterfaceContext> = getRuleContexts(FieldInInterfaceContext::class)
        public fun findFieldInInterface(i: Int): FieldInInterfaceContext? = getRuleContext(FieldInInterfaceContext::class, i)
        public fun COLON(): List<TerminalNode> = getTokens(Tokens.COLON.id)
        public fun COLON(i: Int): TerminalNode = getToken(Tokens.COLON.id, i)!!
        public fun findImpl(): List<ImplContext> = getRuleContexts(ImplContext::class)
        public fun findImpl(i: Int): ImplContext? = getRuleContext(ImplContext::class, i)
        public fun findDefInInterface(): List<DefInInterfaceContext> = getRuleContexts(DefInInterfaceContext::class)
        public fun findDefInInterface(i: Int): DefInInterfaceContext? = getRuleContext(DefInInterfaceContext::class, i)
        public fun findDef(): List<DefContext> = getRuleContexts(DefContext::class)
        public fun findDef(i: Int): DefContext? = getRuleContext(DefContext::class, i)

        public constructor(ctx: Class_Context) {
            copyFrom(ctx)
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterJustInterface(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitJustInterface(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitJustInterface(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }

    public open class JustAbstractClassContext : Class_Context {
        public fun CLASS(): TerminalNode? = getToken(Tokens.CLASS.id, 0)
        public fun findCommonClassIdentifier(): CommonClassIdentifierContext? = getRuleContext(CommonClassIdentifierContext::class, 0)
        public fun LBRACE(): TerminalNode? = getToken(Tokens.LBRACE.id, 0)
        public fun RBRACE(): TerminalNode? = getToken(Tokens.RBRACE.id, 0)
        public fun findAnnotationBlock(): AnnotationBlockContext? = getRuleContext(AnnotationBlockContext::class, 0)
        public fun ABSTRACT(): TerminalNode? = getToken(Tokens.ABSTRACT.id, 0)
        public fun DATA(): TerminalNode? = getToken(Tokens.DATA.id, 0)
        public fun LPAREN(): TerminalNode? = getToken(Tokens.LPAREN.id, 0)
        public fun findTypeParam(): TypeParamContext? = getRuleContext(TypeParamContext::class, 0)
        public fun RPAREN(): TerminalNode? = getToken(Tokens.RPAREN.id, 0)
        public fun findConstructorSelf(): ConstructorSelfContext? = getRuleContext(ConstructorSelfContext::class, 0)
        public fun COLONSHARP(): List<TerminalNode> = getTokens(Tokens.COLONSHARP.id)
        public fun COLONSHARP(i: Int): TerminalNode = getToken(Tokens.COLONSHARP.id, i)!!
        public fun COLON(): List<TerminalNode> = getTokens(Tokens.COLON.id)
        public fun COLON(i: Int): TerminalNode = getToken(Tokens.COLON.id, i)!!
        public fun findInherit(): InheritContext? = getRuleContext(InheritContext::class, 0)
        public fun findImpl(): List<ImplContext> = getRuleContexts(ImplContext::class)
        public fun findImpl(i: Int): ImplContext? = getRuleContext(ImplContext::class, i)
        public fun findField(): List<FieldContext> = getRuleContexts(FieldContext::class)
        public fun findField(i: Int): FieldContext? = getRuleContext(FieldContext::class, i)
        public fun findFieldInInterface(): List<FieldInInterfaceContext> = getRuleContexts(FieldInInterfaceContext::class)
        public fun findFieldInInterface(i: Int): FieldInInterfaceContext? = getRuleContext(FieldInInterfaceContext::class, i)
        public fun findDefInInterface(): List<DefInInterfaceContext> = getRuleContexts(DefInInterfaceContext::class)
        public fun findDefInInterface(i: Int): DefInInterfaceContext? = getRuleContext(DefInInterfaceContext::class, i)
        public fun findDef(): List<DefContext> = getRuleContexts(DefContext::class)
        public fun findDef(i: Int): DefContext? = getRuleContext(DefContext::class, i)

        public constructor(ctx: Class_Context) {
            copyFrom(ctx)
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterJustAbstractClass(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitJustAbstractClass(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitJustAbstractClass(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }

    public open class JustClassContext : Class_Context {
        public fun CLASS(): TerminalNode? = getToken(Tokens.CLASS.id, 0)
        public fun findCommonClassIdentifier(): CommonClassIdentifierContext? = getRuleContext(CommonClassIdentifierContext::class, 0)
        public fun LBRACE(): TerminalNode? = getToken(Tokens.LBRACE.id, 0)
        public fun findConstructorSelf(): ConstructorSelfContext? = getRuleContext(ConstructorSelfContext::class, 0)
        public fun RBRACE(): TerminalNode? = getToken(Tokens.RBRACE.id, 0)
        public fun findAnnotationBlock(): AnnotationBlockContext? = getRuleContext(AnnotationBlockContext::class, 0)
        public fun DATA(): TerminalNode? = getToken(Tokens.DATA.id, 0)
        public fun LPAREN(): TerminalNode? = getToken(Tokens.LPAREN.id, 0)
        public fun findTypeParam(): TypeParamContext? = getRuleContext(TypeParamContext::class, 0)
        public fun RPAREN(): TerminalNode? = getToken(Tokens.RPAREN.id, 0)
        public fun COLONSHARP(): List<TerminalNode> = getTokens(Tokens.COLONSHARP.id)
        public fun COLONSHARP(i: Int): TerminalNode = getToken(Tokens.COLONSHARP.id, i)!!
        public fun findField(): List<FieldContext> = getRuleContexts(FieldContext::class)
        public fun findField(i: Int): FieldContext? = getRuleContext(FieldContext::class, i)
        public fun COLON(): List<TerminalNode> = getTokens(Tokens.COLON.id)
        public fun COLON(i: Int): TerminalNode = getToken(Tokens.COLON.id, i)!!
        public fun findDef(): List<DefContext> = getRuleContexts(DefContext::class)
        public fun findDef(i: Int): DefContext? = getRuleContext(DefContext::class, i)
        public fun INHERIT(): TerminalNode? = getToken(Tokens.INHERIT.id, 0)
        public fun findInherit(): InheritContext? = getRuleContext(InheritContext::class, 0)
        public fun findImpl(): List<ImplContext> = getRuleContexts(ImplContext::class)
        public fun findImpl(i: Int): ImplContext? = getRuleContext(ImplContext::class, i)

        public constructor(ctx: Class_Context) {
            copyFrom(ctx)
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterJustClass(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitJustClass(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitJustClass(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun class_(): Class_Context {
        var _localctx = Class_Context(context, state)
        enterRule(_localctx, 36, Rules.RULE_class_.id)
        var _la: Int

        try {
            this.state = 417
            errorHandler.sync(this)

            when (interpreter!!.adaptivePredict(_input!!, 45, context)) {
                1 -> {
                    _localctx = JustInterfaceContext(_localctx)
                    enterOuterAlt(_localctx, 1)
                    scoped {
                        this.state = 281
                        errorHandler.sync(this)
                        _la = _input!!.LA(1)

                        if (_la == LSQUARE) {
                            scoped {
                                this.state = 280
                                annotationBlock()
                            }
                        }
                        this.state = 284
                        errorHandler.sync(this)
                        _la = _input!!.LA(1)

                        if (_la == ABSTRACT) {
                            scoped {
                                this.state = 283
                                match(ABSTRACT)
                            }
                        }
                        this.state = 287
                        errorHandler.sync(this)
                        _la = _input!!.LA(1)

                        if (_la == INTERFACE) {
                            scoped {
                                this.state = 286
                                match(INTERFACE)
                            }
                        }
                        this.state = 289
                        match(CLASS)
                        this.state = 290
                        commonClassIdentifier()
                        this.state = 295
                        errorHandler.sync(this)
                        _la = _input!!.LA(1)

                        if (_la == LPAREN) {
                            scoped {
                                this.state = 291
                                match(LPAREN)
                                this.state = 292
                                typeParam()
                                this.state = 293
                                match(RPAREN)
                            }
                        }
                        this.state = 297
                        match(LBRACE)
                        this.state = 302
                        errorHandler.sync(this)
                        _la = _input!!.LA(1)

                        while (_la == COLONSHARP) {
                            scoped {
                                scoped {
                                    this.state = 298
                                    match(COLONSHARP)
                                    this.state = 299
                                    fieldInInterface()
                                }
                            }
                            this.state = 304
                            errorHandler.sync(this)
                            _la = _input!!.LA(1)
                        }
                        this.state = 312
                        errorHandler.sync(this)
                        _la = _input!!.LA(1)

                        while (_la == COLON) {
                            scoped {
                                scoped {
                                    this.state = 305
                                    match(COLON)
                                    this.state = 308
                                    errorHandler.sync(this)

                                    when (interpreter!!.adaptivePredict(_input!!, 24, context)) {
                                        1 -> {
                                            scoped {
                                                this.state = 306
                                                defInInterface()
                                            }
                                        }2 -> {
                                            scoped {
                                                this.state = 307
                                                def()
                                            }
                                        }
                                    }
                                }
                            }
                            this.state = 314
                            errorHandler.sync(this)
                            _la = _input!!.LA(1)
                        }
                        this.state = 318
                        errorHandler.sync(this)
                        _la = _input!!.LA(1)

                        while (_la == IMPL) {
                            scoped {
                                scoped {
                                    this.state = 315
                                    impl()
                                }
                            }
                            this.state = 320
                            errorHandler.sync(this)
                            _la = _input!!.LA(1)
                        }
                        this.state = 321
                        match(RBRACE)
                    }
                }2 -> {
                    _localctx = JustClassContext(_localctx)
                    enterOuterAlt(_localctx, 2)
                    scoped {
                        this.state = 324
                        errorHandler.sync(this)
                        _la = _input!!.LA(1)

                        if (_la == LSQUARE) {
                            scoped {
                                this.state = 323
                                annotationBlock()
                            }
                        }
                        this.state = 327
                        errorHandler.sync(this)
                        _la = _input!!.LA(1)

                        if (_la == DATA) {
                            scoped {
                                this.state = 326
                                match(DATA)
                            }
                        }
                        this.state = 329
                        match(CLASS)
                        this.state = 330
                        commonClassIdentifier()
                        this.state = 335
                        errorHandler.sync(this)
                        _la = _input!!.LA(1)

                        if (_la == LPAREN) {
                            scoped {
                                this.state = 331
                                match(LPAREN)
                                this.state = 332
                                typeParam()
                                this.state = 333
                                match(RPAREN)
                            }
                        }
                        this.state = 337
                        match(LBRACE)
                        this.state = 338
                        constructorSelf()
                        this.state = 343
                        errorHandler.sync(this)
                        _la = _input!!.LA(1)

                        while (_la == COLONSHARP) {
                            scoped {
                                scoped {
                                    this.state = 339
                                    match(COLONSHARP)
                                    this.state = 340
                                    field()
                                }
                            }
                            this.state = 345
                            errorHandler.sync(this)
                            _la = _input!!.LA(1)
                        }
                        this.state = 350
                        errorHandler.sync(this)
                        _la = _input!!.LA(1)

                        while (_la == COLON) {
                            scoped {
                                scoped {
                                    this.state = 346
                                    match(COLON)
                                    this.state = 347
                                    def()
                                }
                            }
                            this.state = 352
                            errorHandler.sync(this)
                            _la = _input!!.LA(1)
                        }
                        this.state = 355
                        errorHandler.sync(this)
                        _la = _input!!.LA(1)

                        if (_la == INHERIT) {
                            scoped {
                                this.state = 353
                                match(INHERIT)
                                this.state = 354
                                inherit()
                            }
                        }
                        this.state = 360
                        errorHandler.sync(this)
                        _la = _input!!.LA(1)

                        while (_la == IMPL) {
                            scoped {
                                scoped {
                                    this.state = 357
                                    impl()
                                }
                            }
                            this.state = 362
                            errorHandler.sync(this)
                            _la = _input!!.LA(1)
                        }
                        this.state = 363
                        match(RBRACE)
                    }
                }3 -> {
                    _localctx = JustAbstractClassContext(_localctx)
                    enterOuterAlt(_localctx, 3)
                    scoped {
                        this.state = 366
                        errorHandler.sync(this)
                        _la = _input!!.LA(1)

                        if (_la == LSQUARE) {
                            scoped {
                                this.state = 365
                                annotationBlock()
                            }
                        }
                        this.state = 369
                        errorHandler.sync(this)
                        _la = _input!!.LA(1)

                        if (_la == ABSTRACT) {
                            scoped {
                                this.state = 368
                                match(ABSTRACT)
                            }
                        }
                        this.state = 372
                        errorHandler.sync(this)
                        _la = _input!!.LA(1)

                        if (_la == DATA) {
                            scoped {
                                this.state = 371
                                match(DATA)
                            }
                        }
                        this.state = 374
                        match(CLASS)
                        this.state = 375
                        commonClassIdentifier()
                        this.state = 380
                        errorHandler.sync(this)
                        _la = _input!!.LA(1)

                        if (_la == LPAREN) {
                            scoped {
                                this.state = 376
                                match(LPAREN)
                                this.state = 377
                                typeParam()
                                this.state = 378
                                match(RPAREN)
                            }
                        }
                        this.state = 382
                        match(LBRACE)
                        this.state = 384
                        errorHandler.sync(this)

                        when (interpreter!!.adaptivePredict(_input!!, 38, context)) {
                            1 -> scoped {
                            this.state = 383
                            constructorSelf()
                        }
                        }
                        this.state = 393
                        errorHandler.sync(this)
                        _la = _input!!.LA(1)

                        while (_la == COLONSHARP) {
                            scoped {
                                scoped {
                                    this.state = 386
                                    match(COLONSHARP)
                                    this.state = 389
                                    errorHandler.sync(this)

                                    when (interpreter!!.adaptivePredict(_input!!, 39, context)) {
                                        1 -> {
                                            scoped {
                                                this.state = 387
                                                field()
                                            }
                                        }2 -> {
                                            scoped {
                                                this.state = 388
                                                fieldInInterface()
                                            }
                                        }
                                    }
                                }
                            }
                            this.state = 395
                            errorHandler.sync(this)
                            _la = _input!!.LA(1)
                        }
                        this.state = 403
                        errorHandler.sync(this)
                        _la = _input!!.LA(1)

                        while (_la == COLON) {
                            scoped {
                                scoped {
                                    this.state = 396
                                    match(COLON)
                                    this.state = 399
                                    errorHandler.sync(this)

                                    when (interpreter!!.adaptivePredict(_input!!, 41, context)) {
                                        1 -> {
                                            scoped {
                                                this.state = 397
                                                defInInterface()
                                            }
                                        }2 -> {
                                            scoped {
                                                this.state = 398
                                                def()
                                            }
                                        }
                                    }
                                }
                            }
                            this.state = 405
                            errorHandler.sync(this)
                            _la = _input!!.LA(1)
                        }
                        this.state = 407
                        errorHandler.sync(this)
                        _la = _input!!.LA(1)

                        if (_la == INHERIT) {
                            scoped {
                                this.state = 406
                                inherit()
                            }
                        }
                        this.state = 412
                        errorHandler.sync(this)
                        _la = _input!!.LA(1)

                        while (_la == IMPL) {
                            scoped {
                                scoped {
                                    this.state = 409
                                    impl()
                                }
                            }
                            this.state = 414
                            errorHandler.sync(this)
                            _la = _input!!.LA(1)
                        }
                        this.state = 415
                        match(RBRACE)
                    }
                }
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class Constructor_Context : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_constructor_.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()

        public fun ID(): TerminalNode? = getToken(Tokens.ID.id, 0)
        public fun LPAREN(): TerminalNode? = getToken(Tokens.LPAREN.id, 0)
        public fun findParameter(): ParameterContext? = getRuleContext(ParameterContext::class, 0)
        public fun RPAREN(): TerminalNode? = getToken(Tokens.RPAREN.id, 0)
        public fun findDoBlock(): DoBlockContext? = getRuleContext(DoBlockContext::class, 0)

        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterConstructor_(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitConstructor_(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitConstructor_(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun constructor_(): Constructor_Context {
        var _localctx = Constructor_Context(context, state)
        enterRule(_localctx, 38, Rules.RULE_constructor_.id)
        var _la: Int

        try {
            enterOuterAlt(_localctx, 1)
            scoped {
                this.state = 419
                match(ID)
                this.state = 424
                errorHandler.sync(this)
                _la = _input!!.LA(1)

                if (_la == LPAREN) {
                    scoped {
                        this.state = 420
                        match(LPAREN)
                        this.state = 421
                        parameter()
                        this.state = 422
                        match(RPAREN)
                    }
                }
                this.state = 427
                errorHandler.sync(this)
                _la = _input!!.LA(1)

                if (_la == DO) {
                    scoped {
                        this.state = 426
                        doBlock()
                    }
                }
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class ConstructorSelfContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_constructorSelf.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()

        public fun LPAREN(): TerminalNode? = getToken(Tokens.LPAREN.id, 0)
        public fun findParameter(): ParameterContext? = getRuleContext(ParameterContext::class, 0)
        public fun RPAREN(): TerminalNode? = getToken(Tokens.RPAREN.id, 0)
        public fun findDoBlock(): DoBlockContext? = getRuleContext(DoBlockContext::class, 0)

        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterConstructorSelf(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitConstructorSelf(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitConstructorSelf(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun constructorSelf(): ConstructorSelfContext {
        var _localctx = ConstructorSelfContext(context, state)
        enterRule(_localctx, 40, Rules.RULE_constructorSelf.id)
        var _la: Int

        try {
            enterOuterAlt(_localctx, 1)
            scoped {
                this.state = 433
                errorHandler.sync(this)
                _la = _input!!.LA(1)

                if (_la == LPAREN) {
                    scoped {
                        this.state = 429
                        match(LPAREN)
                        this.state = 430
                        parameter()
                        this.state = 431
                        match(RPAREN)
                    }
                }
                this.state = 436
                errorHandler.sync(this)
                _la = _input!!.LA(1)

                if (_la == DO) {
                    scoped {
                        this.state = 435
                        doBlock()
                    }
                }
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class DefInInterfaceContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_defInInterface.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()

        public fun findCommonIdentifier(): CommonIdentifierContext? = getRuleContext(CommonIdentifierContext::class, 0)
        public fun findTypeEx(): TypeExContext? = getRuleContext(TypeExContext::class, 0)
        public fun findAnnotationBlock(): AnnotationBlockContext? = getRuleContext(AnnotationBlockContext::class, 0)
        public fun findTypeParam(): TypeParamContext? = getRuleContext(TypeParamContext::class, 0)
        public fun LPAREN(): TerminalNode? = getToken(Tokens.LPAREN.id, 0)
        public fun findParameter(): ParameterContext? = getRuleContext(ParameterContext::class, 0)
        public fun RPAREN(): TerminalNode? = getToken(Tokens.RPAREN.id, 0)

        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterDefInInterface(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitDefInInterface(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitDefInInterface(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun defInInterface(): DefInInterfaceContext {
        var _localctx = DefInInterfaceContext(context, state)
        enterRule(_localctx, 42, Rules.RULE_defInInterface.id)

        try {
            enterOuterAlt(_localctx, 1)
            scoped {
                this.state = 439
                errorHandler.sync(this)

                when (interpreter!!.adaptivePredict(_input!!, 50, context)) {
                    1 -> scoped {
                    this.state = 438
                    annotationBlock()
                }
                }
                this.state = 441
                commonIdentifier()
                this.state = 443
                errorHandler.sync(this)

                when (interpreter!!.adaptivePredict(_input!!, 51, context)) {
                    1 -> scoped {
                    this.state = 442
                    typeParam()
                }
                }
                this.state = 449
                errorHandler.sync(this)

                when (interpreter!!.adaptivePredict(_input!!, 52, context)) {
                    1 -> scoped {
                    this.state = 445
                    match(LPAREN)
                    this.state = 446
                    parameter()
                    this.state = 447
                    match(RPAREN)
                }
                }
                this.state = 451
                typeEx()
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class FieldInInterfaceContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_fieldInInterface.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()

        public fun findFieldNotInit(): FieldNotInitContext? = getRuleContext(FieldNotInitContext::class, 0)
        public fun LPAREN(): TerminalNode? = getToken(Tokens.LPAREN.id, 0)
        public fun ABSTRACT(): TerminalNode? = getToken(Tokens.ABSTRACT.id, 0)
        public fun RPAREN(): TerminalNode? = getToken(Tokens.RPAREN.id, 0)

        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterFieldInInterface(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitFieldInInterface(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitFieldInInterface(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun fieldInInterface(): FieldInInterfaceContext {
        var _localctx = FieldInInterfaceContext(context, state)
        enterRule(_localctx, 44, Rules.RULE_fieldInInterface.id)

        try {
            enterOuterAlt(_localctx, 1)
            scoped {
                scoped {
                    this.state = 453
                    match(LPAREN)
                    this.state = 454
                    match(ABSTRACT)
                    this.state = 455
                    match(RPAREN)
                }
                this.state = 457
                fieldNotInit()
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class InheritContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_inherit.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()

        public fun INHERIT(): TerminalNode? = getToken(Tokens.INHERIT.id, 0)
        public fun findTypeEx(): TypeExContext? = getRuleContext(TypeExContext::class, 0)
        public fun LBRACE(): TerminalNode? = getToken(Tokens.LBRACE.id, 0)
        public fun RBRACE(): TerminalNode? = getToken(Tokens.RBRACE.id, 0)
        public fun findArgValue(): ArgValueContext? = getRuleContext(ArgValueContext::class, 0)
        public fun findImplBody(): ImplBodyContext? = getRuleContext(ImplBodyContext::class, 0)

        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterInherit(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitInherit(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitInherit(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun inherit(): InheritContext {
        var _localctx = InheritContext(context, state)
        enterRule(_localctx, 46, Rules.RULE_inherit.id)
        var _la: Int

        try {
            enterOuterAlt(_localctx, 1)
            scoped {
                this.state = 459
                match(INHERIT)
                this.state = 460
                typeEx()
                this.state = 475
                errorHandler.sync(this)

                when (interpreter!!.adaptivePredict(_input!!, 57, context)) {
                    1 -> {
                        scoped {
                            this.state = 461
                            match(LBRACE)
                            this.state = 463
                            errorHandler.sync(this)
                            _la = _input!!.LA(1)

                            if (_la == LPAREN || _la == LBRACE) {
                                scoped {
                                    this.state = 462
                                    argValue()
                                }
                            }
                            this.state = 466
                            errorHandler.sync(this)
                            _la = _input!!.LA(1)

                            if (_la == COLON || _la == COLONSHARP) {
                                scoped {
                                    this.state = 465
                                    implBody()
                                }
                            }
                            this.state = 468
                            match(RBRACE)
                        }
                    }2 -> {
                        scoped {
                            this.state = 470
                            errorHandler.sync(this)

                            when (interpreter!!.adaptivePredict(_input!!, 55, context)) {
                                1 -> scoped {
                                this.state = 469
                                argValue()
                            }
                            }
                            this.state = 473
                            errorHandler.sync(this)

                            when (interpreter!!.adaptivePredict(_input!!, 56, context)) {
                                1 -> scoped {
                                this.state = 472
                                implBody()
                            }
                            }
                        }
                    }
                }
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class ImplContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_impl.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()

        public fun IMPL(): TerminalNode? = getToken(Tokens.IMPL.id, 0)
        public fun findTypeEx(): TypeExContext? = getRuleContext(TypeExContext::class, 0)
        public fun LBRACE(): TerminalNode? = getToken(Tokens.LBRACE.id, 0)
        public fun RBRACE(): TerminalNode? = getToken(Tokens.RBRACE.id, 0)
        public fun findImplBody(): ImplBodyContext? = getRuleContext(ImplBodyContext::class, 0)

        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterImpl(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitImpl(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitImpl(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun impl(): ImplContext {
        var _localctx = ImplContext(context, state)
        enterRule(_localctx, 48, Rules.RULE_impl.id)
        var _la: Int

        try {
            enterOuterAlt(_localctx, 1)
            scoped {
                this.state = 477
                match(IMPL)
                this.state = 478
                typeEx()
                this.state = 487
                errorHandler.sync(this)

                when (interpreter!!.adaptivePredict(_input!!, 60, context)) {
                    1 -> {
                        scoped {
                            this.state = 479
                            match(LBRACE)
                            this.state = 481
                            errorHandler.sync(this)
                            _la = _input!!.LA(1)

                            if (_la == COLON || _la == COLONSHARP) {
                                scoped {
                                    this.state = 480
                                    implBody()
                                }
                            }
                            this.state = 483
                            match(RBRACE)
                        }
                    }2 -> {
                        scoped {
                            this.state = 485
                            errorHandler.sync(this)

                            when (interpreter!!.adaptivePredict(_input!!, 59, context)) {
                                1 -> scoped {
                                this.state = 484
                                implBody()
                            }
                            }
                        }
                    }
                }
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class ImplBodyContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_implBody.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()

        public fun COLONSHARP(): List<TerminalNode> = getTokens(Tokens.COLONSHARP.id)
        public fun COLONSHARP(i: Int): TerminalNode = getToken(Tokens.COLONSHARP.id, i)!!
        public fun findField(): List<FieldContext> = getRuleContexts(FieldContext::class)
        public fun findField(i: Int): FieldContext? = getRuleContext(FieldContext::class, i)
        public fun COLON(): List<TerminalNode> = getTokens(Tokens.COLON.id)
        public fun COLON(i: Int): TerminalNode = getToken(Tokens.COLON.id, i)!!
        public fun findDef(): List<DefContext> = getRuleContexts(DefContext::class)
        public fun findDef(i: Int): DefContext? = getRuleContext(DefContext::class, i)

        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterImplBody(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitImplBody(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitImplBody(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun implBody(): ImplBodyContext {
        var _localctx = ImplBodyContext(context, state)
        enterRule(_localctx, 50, Rules.RULE_implBody.id)
        var _la: Int

        try {
            var _alt: Int
            this.state = 513
            errorHandler.sync(this)

            when (interpreter!!.adaptivePredict(_input!!, 65, context)) {
                1 -> {
                    enterOuterAlt(_localctx, 1)
                    scoped {
                        this.state = 491 
                        errorHandler.sync(this)
                        _alt = 1

                        do {
                            when (_alt) {
                                1 -> scoped {
                            scoped {
                                this.state = 489
                                match(COLONSHARP)
                                this.state = 490
                                field()
                            }
                        }
                                else -> throw NoViableAltException(this)
                            }

                            this.state = 493 
                            errorHandler.sync(this)
                            _alt = interpreter!!.adaptivePredict(_input!!,61,context)
                        } while (_alt != 2 && _alt != INVALID_ALT_NUMBER)
                    }
                }2 -> {
                    enterOuterAlt(_localctx, 2)
                    scoped {
                        this.state = 497 
                        errorHandler.sync(this)
                        _alt = 1

                        do {
                            when (_alt) {
                                1 -> scoped {
                            scoped {
                                this.state = 495
                                match(COLON)
                                this.state = 496
                                def()
                            }
                        }
                                else -> throw NoViableAltException(this)
                            }

                            this.state = 499 
                            errorHandler.sync(this)
                            _alt = interpreter!!.adaptivePredict(_input!!,62,context)
                        } while (_alt != 2 && _alt != INVALID_ALT_NUMBER)
                    }
                }3 -> {
                    enterOuterAlt(_localctx, 3)
                    scoped {
                        this.state = 503 
                        errorHandler.sync(this)
                        _la = _input!!.LA(1)

                        do {
                            scoped {
                                scoped {
                                    this.state = 501
                                    match(COLONSHARP)
                                    this.state = 502
                                    field()
                                }
                            }
                            this.state = 505 
                            errorHandler.sync(this)
                            _la = _input!!.LA(1)
                        } while (_la == COLONSHARP)
                        this.state = 509 
                        errorHandler.sync(this)
                        _alt = 1

                        do {
                            when (_alt) {
                                1 -> scoped {
                            scoped {
                                this.state = 507
                                match(COLON)
                                this.state = 508
                                def()
                            }
                        }
                                else -> throw NoViableAltException(this)
                            }

                            this.state = 511 
                            errorHandler.sync(this)
                            _alt = interpreter!!.adaptivePredict(_input!!,64,context)
                        } while (_alt != 2 && _alt != INVALID_ALT_NUMBER)
                    }
                }
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class TypeParamContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_typeParam.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()

        public fun findTypeParamCompo(): List<TypeParamCompoContext> = getRuleContexts(TypeParamCompoContext::class)
        public fun findTypeParamCompo(i: Int): TypeParamCompoContext? = getRuleContext(TypeParamCompoContext::class, i)

        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterTypeParam(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitTypeParam(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitTypeParam(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun typeParam(): TypeParamContext {
        var _localctx = TypeParamContext(context, state)
        enterRule(_localctx, 52, Rules.RULE_typeParam.id)

        try {
            var _alt: Int
            enterOuterAlt(_localctx, 1)
            scoped {
                this.state = 516 
                errorHandler.sync(this)
                _alt = 1

                do {
                    when (_alt) {
                        1 -> scoped {
                    scoped {
                        this.state = 515
                        typeParamCompo()
                    }
                }
                        else -> throw NoViableAltException(this)
                    }

                    this.state = 518 
                    errorHandler.sync(this)
                    _alt = interpreter!!.adaptivePredict(_input!!,66,context)
                } while (_alt != 2 && _alt != INVALID_ALT_NUMBER)
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class TypeParamCompoContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_typeParamCompo.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()

        public fun findCommonClassIdentifier(): CommonClassIdentifierContext? = getRuleContext(CommonClassIdentifierContext::class, 0)
        public fun TILDE(): List<TerminalNode> = getTokens(Tokens.TILDE.id)
        public fun TILDE(i: Int): TerminalNode = getToken(Tokens.TILDE.id, i)!!
        public fun findTypeEx(): List<TypeExContext> = getRuleContexts(TypeExContext::class)
        public fun findTypeEx(i: Int): TypeExContext? = getRuleContext(TypeExContext::class, i)

        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterTypeParamCompo(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitTypeParamCompo(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitTypeParamCompo(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun typeParamCompo(): TypeParamCompoContext {
        var _localctx = TypeParamCompoContext(context, state)
        enterRule(_localctx, 54, Rules.RULE_typeParamCompo.id)
        var _la: Int

        try {
            enterOuterAlt(_localctx, 1)
            scoped {
                this.state = 520
                commonClassIdentifier()
                this.state = 525
                errorHandler.sync(this)
                _la = _input!!.LA(1)

                while (_la == TILDE) {
                    scoped {
                        scoped {
                            this.state = 521
                            match(TILDE)
                            this.state = 522
                            typeEx()
                        }
                    }
                    this.state = 527
                    errorHandler.sync(this)
                    _la = _input!!.LA(1)
                }
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class DefinitionContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_definition.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()

        public fun findDef(): DefContext? = getRuleContext(DefContext::class, 0)
        public fun findClass_(): Class_Context? = getRuleContext(Class_Context::class, 0)

        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterDefinition(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitDefinition(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitDefinition(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun definition(): DefinitionContext {
        var _localctx = DefinitionContext(context, state)
        enterRule(_localctx, 56, Rules.RULE_definition.id)

        try {
            this.state = 530
            errorHandler.sync(this)

            when (interpreter!!.adaptivePredict(_input!!, 68, context)) {
                1 -> {
                    enterOuterAlt(_localctx, 1)
                    scoped {
                        this.state = 528
                        def()
                    }
                }2 -> {
                    enterOuterAlt(_localctx, 2)
                    scoped {
                        this.state = 529
                        class_()
                    }
                }
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class DefaultValueContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_defaultValue.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()

        public fun Integer(): TerminalNode? = getToken(Tokens.Integer.id, 0)
        public fun Double(): TerminalNode? = getToken(Tokens.Double.id, 0)
        public fun String(): TerminalNode? = getToken(Tokens.String.id, 0)
        public fun findBoolean(): BooleanContext? = getRuleContext(BooleanContext::class, 0)

        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterDefaultValue(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitDefaultValue(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitDefaultValue(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun defaultValue(): DefaultValueContext {
        var _localctx = DefaultValueContext(context, state)
        enterRule(_localctx, 58, Rules.RULE_defaultValue.id)

        try {
            this.state = 536
            errorHandler.sync(this)

            when (_input!!.LA(1)) {
                Integer  ->  /*LL1AltBlock*/ {
                    enterOuterAlt(_localctx, 1)
                    scoped {
                        this.state = 532
                        match(Integer)
                    }
                }Double  ->  /*LL1AltBlock*/ {
                    enterOuterAlt(_localctx, 2)
                    scoped {
                        this.state = 533
                        match(Double)
                    }
                }String  ->  /*LL1AltBlock*/ {
                    enterOuterAlt(_localctx, 3)
                    scoped {
                        this.state = 534
                        match(String)
                    }
                }TRUE , FALSE  ->  /*LL1AltBlock*/ {
                    enterOuterAlt(_localctx, 4)
                    scoped {
                        this.state = 535
                        boolean()
                    }
                }
                else -> throw NoViableAltException(this)
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class BooleanContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_boolean.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()

        public fun TRUE(): TerminalNode? = getToken(Tokens.TRUE.id, 0)
        public fun FALSE(): TerminalNode? = getToken(Tokens.FALSE.id, 0)

        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterBoolean(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitBoolean(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitBoolean(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun boolean(): BooleanContext {
        var _localctx = BooleanContext(context, state)
        enterRule(_localctx, 60, Rules.RULE_boolean.id)
        var _la: Int

        try {
            enterOuterAlt(_localctx, 1)
            scoped {
                this.state = 538
                _la = _input!!.LA(1)

                if (!(_la == TRUE || _la == FALSE)) {
                    errorHandler.recoverInline(this)
                }
                else {
                    if (_input!!.LA(1) == Tokens.EOF.id) {
                        isMatchedEOF = true
                    }

                    errorHandler.reportMatch(this)
                    consume()
                }
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class ValueContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_value.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()


        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

     
        public constructor() : super()

        public fun copyFrom(ctx: ValueContext) {
            super.copyFrom(ctx)
        }

    }

    public open class CallMethodContext : ValueContext {
        public fun findValue(): ValueContext? = getRuleContext(ValueContext::class, 0)
        public fun COLON(): TerminalNode? = getToken(Tokens.COLON.id, 0)
        public fun findCommonIdentifier(): CommonIdentifierContext? = getRuleContext(CommonIdentifierContext::class, 0)
        public fun findArgValue(): ArgValueContext? = getRuleContext(ArgValueContext::class, 0)

        public constructor(ctx: ValueContext) {
            copyFrom(ctx)
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterCallMethod(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitCallMethod(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitCallMethod(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }

    public open class ReflectedContext : ValueContext {
        public fun QUOTE(): TerminalNode? = getToken(Tokens.QUOTE.id, 0)
        public fun findReference(): ReferenceContext? = getRuleContext(ReferenceContext::class, 0)

        public constructor(ctx: ValueContext) {
            copyFrom(ctx)
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterReflected(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitReflected(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitReflected(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }

    public open class CallFunctionContext : ValueContext {
        public fun findReference(): ReferenceContext? = getRuleContext(ReferenceContext::class, 0)
        public fun findArgValue(): ArgValueContext? = getRuleContext(ArgValueContext::class, 0)

        public constructor(ctx: ValueContext) {
            copyFrom(ctx)
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterCallFunction(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitCallFunction(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitCallFunction(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }

    public open class TypeCheckContext : ValueContext {
        public fun findValue(): ValueContext? = getRuleContext(ValueContext::class, 0)
        public fun IS(): TerminalNode? = getToken(Tokens.IS.id, 0)
        public fun findTypeEx(): TypeExContext? = getRuleContext(TypeExContext::class, 0)
        public fun LPAREN(): TerminalNode? = getToken(Tokens.LPAREN.id, 0)
        public fun RPAREN(): TerminalNode? = getToken(Tokens.RPAREN.id, 0)

        public constructor(ctx: ValueContext) {
            copyFrom(ctx)
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterTypeCheck(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitTypeCheck(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitTypeCheck(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }

    public open class UseForeignClassContext : ValueContext {
        public fun NEW(): TerminalNode? = getToken(Tokens.NEW.id, 0)
        public fun findReference(): ReferenceContext? = getRuleContext(ReferenceContext::class, 0)
        public fun findArgValue(): ArgValueContext? = getRuleContext(ArgValueContext::class, 0)

        public constructor(ctx: ValueContext) {
            copyFrom(ctx)
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterUseForeignClass(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitUseForeignClass(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitUseForeignClass(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }

    public open class CallOpFuncContext : ValueContext {
        public fun findValue(): List<ValueContext> = getRuleContexts(ValueContext::class)
        public fun findValue(i: Int): ValueContext? = getRuleContext(ValueContext::class, i)
        public fun findCommonOpIdentifier(): CommonOpIdentifierContext? = getRuleContext(CommonOpIdentifierContext::class, 0)
        public fun LPAREN(): TerminalNode? = getToken(Tokens.LPAREN.id, 0)
        public fun RPAREN(): TerminalNode? = getToken(Tokens.RPAREN.id, 0)

        public constructor(ctx: ValueContext) {
            copyFrom(ctx)
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterCallOpFunc(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitCallOpFunc(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitCallOpFunc(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }

    public open class TupleContext : ValueContext {
        public fun findTupleEx(): TupleExContext? = getRuleContext(TupleExContext::class, 0)

        public constructor(ctx: ValueContext) {
            copyFrom(ctx)
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterTuple(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitTuple(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitTuple(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }

    public open class JustDefaultValueContext : ValueContext {
        public fun findDefaultValue(): DefaultValueContext? = getRuleContext(DefaultValueContext::class, 0)

        public constructor(ctx: ValueContext) {
            copyFrom(ctx)
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterJustDefaultValue(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitJustDefaultValue(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitJustDefaultValue(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }

    public open class AnonymousClassObjectContext : ValueContext {
        public fun LBRACE(): TerminalNode? = getToken(Tokens.LBRACE.id, 0)
        public fun RBRACE(): TerminalNode? = getToken(Tokens.RBRACE.id, 0)
        public fun findInherit(): InheritContext? = getRuleContext(InheritContext::class, 0)
        public fun findImpl(): List<ImplContext> = getRuleContexts(ImplContext::class)
        public fun findImpl(i: Int): ImplContext? = getRuleContext(ImplContext::class, i)
        public fun COLONSHARP(): List<TerminalNode> = getTokens(Tokens.COLONSHARP.id)
        public fun COLONSHARP(i: Int): TerminalNode = getToken(Tokens.COLONSHARP.id, i)!!
        public fun findField(): List<FieldContext> = getRuleContexts(FieldContext::class)
        public fun findField(i: Int): FieldContext? = getRuleContext(FieldContext::class, i)
        public fun COLON(): List<TerminalNode> = getTokens(Tokens.COLON.id)
        public fun COLON(i: Int): TerminalNode = getToken(Tokens.COLON.id, i)!!
        public fun findDef(): List<DefContext> = getRuleContexts(DefContext::class)
        public fun findDef(i: Int): DefContext? = getRuleContext(DefContext::class, i)
        public fun INHERIT(): TerminalNode? = getToken(Tokens.INHERIT.id, 0)
        public fun IMPL(): List<TerminalNode> = getTokens(Tokens.IMPL.id)
        public fun IMPL(i: Int): TerminalNode = getToken(Tokens.IMPL.id, i)!!

        public constructor(ctx: ValueContext) {
            copyFrom(ctx)
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterAnonymousClassObject(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitAnonymousClassObject(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitAnonymousClassObject(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }

    public open class GetFieldGlobalContext : ValueContext {
        public fun SHARP(): TerminalNode? = getToken(Tokens.SHARP.id, 0)
        public fun findReference(): ReferenceContext? = getRuleContext(ReferenceContext::class, 0)

        public constructor(ctx: ValueContext) {
            copyFrom(ctx)
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterGetFieldGlobal(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitGetFieldGlobal(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitGetFieldGlobal(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }

    public open class LetExpressionContext : ValueContext {
        public fun findLet_binding(): Let_bindingContext? = getRuleContext(Let_bindingContext::class, 0)

        public constructor(ctx: ValueContext) {
            copyFrom(ctx)
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterLetExpression(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitLetExpression(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitLetExpression(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }

    public open class DoExpressionContext : ValueContext {
        public fun findDoBlock(): DoBlockContext? = getRuleContext(DoBlockContext::class, 0)

        public constructor(ctx: ValueContext) {
            copyFrom(ctx)
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterDoExpression(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitDoExpression(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitDoExpression(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }

    public open class InvokeValueLikeMethodContext : ValueContext {
        public fun findValue(): List<ValueContext> = getRuleContexts(ValueContext::class)
        public fun findValue(i: Int): ValueContext? = getRuleContext(ValueContext::class, i)
        public fun TRIPLECOLON(): TerminalNode? = getToken(Tokens.TRIPLECOLON.id, 0)
        public fun findInvoking(): InvokingContext? = getRuleContext(InvokingContext::class, 0)

        public constructor(ctx: ValueContext) {
            copyFrom(ctx)
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterInvokeValueLikeMethod(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitInvokeValueLikeMethod(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitInvokeValueLikeMethod(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }

    public open class IfExpressionContext : ValueContext {
        public fun findIf_else(): If_elseContext? = getRuleContext(If_elseContext::class, 0)

        public constructor(ctx: ValueContext) {
            copyFrom(ctx)
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterIfExpression(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitIfExpression(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitIfExpression(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }

    public open class SimpleIfContext : ValueContext {
        public fun findValue(): List<ValueContext> = getRuleContexts(ValueContext::class)
        public fun findValue(i: Int): ValueContext? = getRuleContext(ValueContext::class, i)
        public fun IF(): TerminalNode? = getToken(Tokens.IF.id, 0)
        public fun LPAREN(): TerminalNode? = getToken(Tokens.LPAREN.id, 0)
        public fun RPAREN(): TerminalNode? = getToken(Tokens.RPAREN.id, 0)

        public constructor(ctx: ValueContext) {
            copyFrom(ctx)
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterSimpleIf(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitSimpleIf(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitSimpleIf(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }

    public open class InvokeValueContext : ValueContext {
        public fun findValue(): ValueContext? = getRuleContext(ValueContext::class, 0)
        public fun findInvoking(): InvokingContext? = getRuleContext(InvokingContext::class, 0)

        public constructor(ctx: ValueContext) {
            copyFrom(ctx)
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterInvokeValue(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitInvokeValue(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitInvokeValue(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }

    public open class OutputOfInversingContext : ValueContext {
        public fun ARROW(): TerminalNode? = getToken(Tokens.ARROW.id, 0)
        public fun ARROWQM(): TerminalNode? = getToken(Tokens.ARROWQM.id, 0)
        public fun ID(): TerminalNode? = getToken(Tokens.ID.id, 0)
        public fun QM(): TerminalNode? = getToken(Tokens.QM.id, 0)

        public constructor(ctx: ValueContext) {
            copyFrom(ctx)
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterOutputOfInversing(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitOutputOfInversing(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitOutputOfInversing(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }

    public open class CallAopFuncContext : ValueContext {
        public fun TILDE(): TerminalNode? = getToken(Tokens.TILDE.id, 0)
        public fun findCommonOpIdentifier(): CommonOpIdentifierContext? = getRuleContext(CommonOpIdentifierContext::class, 0)
        public fun findValue(): ValueContext? = getRuleContext(ValueContext::class, 0)

        public constructor(ctx: ValueContext) {
            copyFrom(ctx)
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterCallAopFunc(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitCallAopFunc(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitCallAopFunc(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }

    public open class CallAopFuncBackContext : ValueContext {
        public fun findValue(): ValueContext? = getRuleContext(ValueContext::class, 0)
        public fun QUOTE(): TerminalNode? = getToken(Tokens.QUOTE.id, 0)
        public fun findCommonOpIdentifier(): CommonOpIdentifierContext? = getRuleContext(CommonOpIdentifierContext::class, 0)
        public fun LPAREN(): TerminalNode? = getToken(Tokens.LPAREN.id, 0)
        public fun RPAREN(): TerminalNode? = getToken(Tokens.RPAREN.id, 0)

        public constructor(ctx: ValueContext) {
            copyFrom(ctx)
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterCallAopFuncBack(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitCallAopFuncBack(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitCallAopFuncBack(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }

    public open class ThisContext : ValueContext {
        public fun THIS(): TerminalNode? = getToken(Tokens.THIS.id, 0)

        public constructor(ctx: ValueContext) {
            copyFrom(ctx)
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterThis(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitThis(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitThis(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }

    public open class GetFieldContext : ValueContext {
        public fun findValue(): ValueContext? = getRuleContext(ValueContext::class, 0)
        public fun COLONSHARP(): TerminalNode? = getToken(Tokens.COLONSHARP.id, 0)
        public fun findCommonIdentifier(): CommonIdentifierContext? = getRuleContext(CommonIdentifierContext::class, 0)

        public constructor(ctx: ValueContext) {
            copyFrom(ctx)
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterGetField(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitGetField(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitGetField(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }

    public open class CallFunctionLikeMethodContext : ValueContext {
        public fun findValue(): ValueContext? = getRuleContext(ValueContext::class, 0)
        public fun DOUBLECOLON(): TerminalNode? = getToken(Tokens.DOUBLECOLON.id, 0)
        public fun findCommonIdentifier(): CommonIdentifierContext? = getRuleContext(CommonIdentifierContext::class, 0)
        public fun findArgValue(): ArgValueContext? = getRuleContext(ArgValueContext::class, 0)

        public constructor(ctx: ValueContext) {
            copyFrom(ctx)
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterCallFunctionLikeMethod(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitCallFunctionLikeMethod(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitCallFunctionLikeMethod(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }

    public open class ReflectedMethodContext : ValueContext {
        public fun findValue(): ValueContext? = getRuleContext(ValueContext::class, 0)
        public fun COLONQUOTE(): TerminalNode? = getToken(Tokens.COLONQUOTE.id, 0)
        public fun findCommonIdentifier(): CommonIdentifierContext? = getRuleContext(CommonIdentifierContext::class, 0)

        public constructor(ctx: ValueContext) {
            copyFrom(ctx)
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterReflectedMethod(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitReflectedMethod(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitReflectedMethod(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }

    public open class JustLambdaContext : ValueContext {
        public fun findLambda(): LambdaContext? = getRuleContext(LambdaContext::class, 0)

        public constructor(ctx: ValueContext) {
            copyFrom(ctx)
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterJustLambda(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitJustLambda(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitJustLambda(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }

    public open class ParenedValueContext : ValueContext {
        public fun LPAREN(): TerminalNode? = getToken(Tokens.LPAREN.id, 0)
        public fun findValue(): ValueContext? = getRuleContext(ValueContext::class, 0)
        public fun RPAREN(): TerminalNode? = getToken(Tokens.RPAREN.id, 0)

        public constructor(ctx: ValueContext) {
            copyFrom(ctx)
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterParenedValue(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitParenedValue(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitParenedValue(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }

    public open class NullContext : ValueContext {
        public fun NULLKEYWORD(): TerminalNode? = getToken(Tokens.NULLKEYWORD.id, 0)

        public constructor(ctx: ValueContext) {
            copyFrom(ctx)
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterNull(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitNull(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitNull(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }

    public open class ValueTypeCastingContext : ValueContext {
        public fun findValue(): ValueContext? = getRuleContext(ValueContext::class, 0)
        public fun findTypeCasting(): TypeCastingContext? = getRuleContext(TypeCastingContext::class, 0)

        public constructor(ctx: ValueContext) {
            copyFrom(ctx)
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterValueTypeCasting(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitValueTypeCasting(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitValueTypeCasting(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }

    public open class PatternMatchExpressionContext : ValueContext {
        public fun findPatternMatch(): PatternMatchContext? = getRuleContext(PatternMatchContext::class, 0)

        public constructor(ctx: ValueContext) {
            copyFrom(ctx)
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterPatternMatchExpression(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitPatternMatchExpression(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitPatternMatchExpression(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun value(): ValueContext {
        return value(0)
    }

    private fun value(_p: Int): ValueContext {
        var _parentctx = context
        var _parentState = state
        var _localctx = ValueContext(context, _parentState)
        var _prevctx = _localctx
        var _startState = 62
        enterRecursionRule(_localctx, 62, Rules.RULE_value.id, _p)
        var _la: Int

        try {
            var _alt: Int
            enterOuterAlt(_localctx, 1)
            scoped {
                this.state = 609
                errorHandler.sync(this)

                when (interpreter!!.adaptivePredict(_input!!, 79, context)) {
                    1 -> {
                        scoped {
                            _localctx = JustDefaultValueContext(_localctx)
                            context = _localctx
                            _prevctx = _localctx

                            this.state = 541
                            defaultValue()
                        }
                    }2 -> {
                        scoped {
                            _localctx = NullContext(_localctx)
                            context = _localctx
                            _prevctx = _localctx
                            this.state = 542
                            match(NULLKEYWORD)
                        }
                    }3 -> {
                        scoped {
                            _localctx = ThisContext(_localctx)
                            context = _localctx
                            _prevctx = _localctx
                            this.state = 543
                            match(THIS)
                        }
                    }4 -> {
                        scoped {
                            _localctx = OutputOfInversingContext(_localctx)
                            context = _localctx
                            _prevctx = _localctx
                            this.state = 547
                            errorHandler.sync(this)

                            when (_input!!.LA(1)) {
                                ARROW  ->  /*LL1AltBlock*/ {
                                    scoped {
                                        this.state = 544
                                        match(ARROW)
                                        this.state = 545
                                        _la = _input!!.LA(1)

                                        if (!(_la == QM || _la == ID)) {
                                            errorHandler.recoverInline(this)
                                        }
                                        else {
                                            if (_input!!.LA(1) == Tokens.EOF.id) {
                                                isMatchedEOF = true
                                            }

                                            errorHandler.reportMatch(this)
                                            consume()
                                        }
                                    }
                                }ARROWQM  ->  /*LL1AltBlock*/ {
                                    scoped {
                                        this.state = 546
                                        match(ARROWQM)
                                    }
                                }
                                else -> throw NoViableAltException(this)
                            }
                        }
                    }5 -> {
                        scoped {
                            _localctx = ReflectedContext(_localctx)
                            context = _localctx
                            _prevctx = _localctx
                            this.state = 549
                            match(QUOTE)
                            this.state = 550
                            reference()
                        }
                    }6 -> {
                        scoped {
                            _localctx = CallFunctionContext(_localctx)
                            context = _localctx
                            _prevctx = _localctx
                            this.state = 551
                            reference()
                            this.state = 553
                            errorHandler.sync(this)

                            when (interpreter!!.adaptivePredict(_input!!, 71, context)) {
                                1 -> scoped {
                                this.state = 552
                                argValue()
                            }
                            }
                        }
                    }7 -> {
                        scoped {
                            _localctx = UseForeignClassContext(_localctx)
                            context = _localctx
                            _prevctx = _localctx
                            this.state = 555
                            match(NEW)
                            this.state = 556
                            reference()
                            this.state = 558
                            errorHandler.sync(this)

                            when (interpreter!!.adaptivePredict(_input!!, 72, context)) {
                                1 -> scoped {
                                this.state = 557
                                argValue()
                            }
                            }
                        }
                    }8 -> {
                        scoped {
                            _localctx = GetFieldGlobalContext(_localctx)
                            context = _localctx
                            _prevctx = _localctx
                            this.state = 560
                            match(SHARP)
                            this.state = 561
                            reference()
                        }
                    }9 -> {
                        scoped {
                            _localctx = AnonymousClassObjectContext(_localctx)
                            context = _localctx
                            _prevctx = _localctx
                            this.state = 593
                            errorHandler.sync(this)

                            when (_input!!.LA(1)) {
                                LBRACE  ->  /*LL1AltBlock*/ {
                                    scoped {
                                        this.state = 562
                                        match(LBRACE)
                                        this.state = 567
                                        errorHandler.sync(this)
                                        _la = _input!!.LA(1)

                                        while (_la == COLONSHARP) {
                                            scoped {
                                                scoped {
                                                    this.state = 563
                                                    match(COLONSHARP)
                                                    this.state = 564
                                                    field()
                                                }
                                            }
                                            this.state = 569
                                            errorHandler.sync(this)
                                            _la = _input!!.LA(1)
                                        }
                                        this.state = 574
                                        errorHandler.sync(this)
                                        _la = _input!!.LA(1)

                                        while (_la == COLON) {
                                            scoped {
                                                scoped {
                                                    this.state = 570
                                                    match(COLON)
                                                    this.state = 571
                                                    def()
                                                }
                                            }
                                            this.state = 576
                                            errorHandler.sync(this)
                                            _la = _input!!.LA(1)
                                        }
                                        this.state = 579
                                        errorHandler.sync(this)
                                        _la = _input!!.LA(1)

                                        if (_la == INHERIT) {
                                            scoped {
                                                this.state = 577
                                                match(INHERIT)
                                                this.state = 578
                                                inherit()
                                            }
                                        }
                                        this.state = 585
                                        errorHandler.sync(this)
                                        _la = _input!!.LA(1)

                                        while (_la == IMPL) {
                                            scoped {
                                                scoped {
                                                    this.state = 581
                                                    match(IMPL)
                                                    this.state = 582
                                                    impl()
                                                }
                                            }
                                            this.state = 587
                                            errorHandler.sync(this)
                                            _la = _input!!.LA(1)
                                        }
                                        this.state = 588
                                        match(RBRACE)
                                    }
                                }IMPL , INHERIT  ->  /*LL1AltBlock*/ {
                                    scoped {
                                        this.state = 591
                                        errorHandler.sync(this)

                                        when (_input!!.LA(1)) {
                                            INHERIT  ->  /*LL1AltBlock*/ {
                                                scoped {
                                                    this.state = 589
                                                    inherit()
                                                }
                                            }IMPL  ->  /*LL1AltBlock*/ {
                                                scoped {
                                                    this.state = 590
                                                    impl()
                                                }
                                            }
                                            else -> throw NoViableAltException(this)
                                        }
                                    }
                                }
                                else -> throw NoViableAltException(this)
                            }
                        }
                    }10 -> {
                        scoped {
                            _localctx = TupleContext(_localctx)
                            context = _localctx
                            _prevctx = _localctx
                            this.state = 595
                            tupleEx()
                        }
                    }11 -> {
                        scoped {
                            _localctx = CallAopFuncContext(_localctx)
                            context = _localctx
                            _prevctx = _localctx
                            this.state = 596
                            match(TILDE)
                            this.state = 597
                            commonOpIdentifier()
                            this.state = 598
                            value(10)
                        }
                    }12 -> {
                        scoped {
                            _localctx = IfExpressionContext(_localctx)
                            context = _localctx
                            _prevctx = _localctx
                            this.state = 600
                            if_else()
                        }
                    }13 -> {
                        scoped {
                            _localctx = PatternMatchExpressionContext(_localctx)
                            context = _localctx
                            _prevctx = _localctx
                            this.state = 601
                            patternMatch()
                        }
                    }14 -> {
                        scoped {
                            _localctx = LetExpressionContext(_localctx)
                            context = _localctx
                            _prevctx = _localctx
                            this.state = 602
                            let_binding()
                        }
                    }15 -> {
                        scoped {
                            _localctx = DoExpressionContext(_localctx)
                            context = _localctx
                            _prevctx = _localctx
                            this.state = 603
                            doBlock()
                        }
                    }16 -> {
                        scoped {
                            _localctx = JustLambdaContext(_localctx)
                            context = _localctx
                            _prevctx = _localctx
                            this.state = 604
                            lambda()
                        }
                    }17 -> {
                        scoped {
                            _localctx = ParenedValueContext(_localctx)
                            context = _localctx
                            _prevctx = _localctx
                            this.state = 605
                            match(LPAREN)
                            this.state = 606
                            value(0)
                            this.state = 607
                            match(RPAREN)
                        }
                    }
                }
                this.context!!.stop = _input!!.LT(-1)
                this.state = 681
                errorHandler.sync(this)
                _alt = interpreter!!.adaptivePredict(_input!!,88,context)

                while (_alt != 2 && _alt != INVALID_ALT_NUMBER) {
                    if (_alt == 1 ) {
                        if (_parseListeners.isNotEmpty()) {
                            triggerExitRuleEvent()
                        }

                        _prevctx = _localctx
                        scoped {
                            this.state = 679
                            errorHandler.sync(this)

                            when (interpreter!!.adaptivePredict(_input!!, 87, context)) {
                                1 -> {
                                    scoped {
                                        _localctx = ValueTypeCastingContext(ValueContext(_parentctx, _parentState))
                                        pushNewRecursionContext(_localctx, _startState, Rules.RULE_value.id)
                                        this.state = 611

                                        if (!(precpred(context!!, 18))) {
                                            throw FailedPredicateException(this, "precpred(context!!, 18)")
                                        }
                                        this.state = 612
                                        typeCasting()
                                    }
                                }2 -> {
                                    scoped {
                                        _localctx = GetFieldContext(ValueContext(_parentctx, _parentState))
                                        pushNewRecursionContext(_localctx, _startState, Rules.RULE_value.id)
                                        this.state = 613

                                        if (!(precpred(context!!, 17))) {
                                            throw FailedPredicateException(this, "precpred(context!!, 17)")
                                        }
                                        this.state = 614
                                        match(COLONSHARP)
                                        this.state = 615
                                        commonIdentifier()
                                    }
                                }3 -> {
                                    scoped {
                                        _localctx = CallMethodContext(ValueContext(_parentctx, _parentState))
                                        pushNewRecursionContext(_localctx, _startState, Rules.RULE_value.id)
                                        this.state = 616

                                        if (!(precpred(context!!, 16))) {
                                            throw FailedPredicateException(this, "precpred(context!!, 16)")
                                        }
                                        this.state = 617
                                        match(COLON)
                                        this.state = 618
                                        commonIdentifier()
                                        this.state = 620
                                        errorHandler.sync(this)

                                        when (interpreter!!.adaptivePredict(_input!!, 80, context)) {
                                            1 -> scoped {
                                            this.state = 619
                                            argValue()
                                        }
                                        }
                                    }
                                }4 -> {
                                    scoped {
                                        _localctx = ReflectedMethodContext(ValueContext(_parentctx, _parentState))
                                        pushNewRecursionContext(_localctx, _startState, Rules.RULE_value.id)
                                        this.state = 622

                                        if (!(precpred(context!!, 15))) {
                                            throw FailedPredicateException(this, "precpred(context!!, 15)")
                                        }
                                        this.state = 623
                                        match(COLONQUOTE)
                                        this.state = 624
                                        commonIdentifier()
                                    }
                                }5 -> {
                                    scoped {
                                        _localctx = CallFunctionLikeMethodContext(ValueContext(_parentctx, _parentState))
                                        pushNewRecursionContext(_localctx, _startState, Rules.RULE_value.id)
                                        this.state = 625

                                        if (!(precpred(context!!, 14))) {
                                            throw FailedPredicateException(this, "precpred(context!!, 14)")
                                        }
                                        this.state = 626
                                        match(DOUBLECOLON)
                                        this.state = 627
                                        commonIdentifier()
                                        this.state = 629
                                        errorHandler.sync(this)

                                        when (interpreter!!.adaptivePredict(_input!!, 81, context)) {
                                            1 -> scoped {
                                            this.state = 628
                                            argValue()
                                        }
                                        }
                                    }
                                }6 -> {
                                    scoped {
                                        _localctx = InvokeValueContext(ValueContext(_parentctx, _parentState))
                                        pushNewRecursionContext(_localctx, _startState, Rules.RULE_value.id)
                                        this.state = 631

                                        if (!(precpred(context!!, 13))) {
                                            throw FailedPredicateException(this, "precpred(context!!, 13)")
                                        }
                                        this.state = 632
                                        invoking()
                                    }
                                }7 -> {
                                    scoped {
                                        _localctx = InvokeValueLikeMethodContext(ValueContext(_parentctx, _parentState))
                                        pushNewRecursionContext(_localctx, _startState, Rules.RULE_value.id)
                                        this.state = 633

                                        if (!(precpred(context!!, 12))) {
                                            throw FailedPredicateException(this, "precpred(context!!, 12)")
                                        }
                                        this.state = 634
                                        match(TRIPLECOLON)
                                        this.state = 635
                                        value(0)
                                        this.state = 637
                                        errorHandler.sync(this)

                                        when (interpreter!!.adaptivePredict(_input!!, 82, context)) {
                                            1 -> scoped {
                                            this.state = 636
                                            invoking()
                                        }
                                        }
                                    }
                                }8 -> {
                                    scoped {
                                        _localctx = CallAopFuncBackContext(ValueContext(_parentctx, _parentState))
                                        pushNewRecursionContext(_localctx, _startState, Rules.RULE_value.id)
                                        this.state = 639

                                        if (!(precpred(context!!, 11))) {
                                            throw FailedPredicateException(this, "precpred(context!!, 11)")
                                        }
                                        this.state = 646
                                        errorHandler.sync(this)

                                        when (_input!!.LA(1)) {
                                            QUOTE  ->  /*LL1AltBlock*/ {
                                                scoped {
                                                    this.state = 640
                                                    match(QUOTE)
                                                    this.state = 641
                                                    commonOpIdentifier()
                                                }
                                            }LPAREN  ->  /*LL1AltBlock*/ {
                                                scoped {
                                                    this.state = 642
                                                    match(LPAREN)
                                                    this.state = 643
                                                    commonOpIdentifier()
                                                    this.state = 644
                                                    match(RPAREN)
                                                }
                                            }
                                            else -> throw NoViableAltException(this)
                                        }
                                    }
                                }9 -> {
                                    scoped {
                                        _localctx = CallOpFuncContext(ValueContext(_parentctx, _parentState))
                                        pushNewRecursionContext(_localctx, _startState, Rules.RULE_value.id)
                                        this.state = 648

                                        if (!(precpred(context!!, 9))) {
                                            throw FailedPredicateException(this, "precpred(context!!, 9)")
                                        }
                                        this.state = 657
                                        errorHandler.sync(this)

                                        when (_input!!.LA(1)) {
                                            LSQUARE , ID , OPID  ->  /*LL1AltBlock*/ {
                                                scoped {
                                                    this.state = 649
                                                    commonOpIdentifier()
                                                    this.state = 650
                                                    value(0)
                                                }
                                            }LPAREN  ->  /*LL1AltBlock*/ {
                                                scoped {
                                                    this.state = 652
                                                    match(LPAREN)
                                                    this.state = 653
                                                    commonOpIdentifier()
                                                    this.state = 654
                                                    value(0)
                                                    this.state = 655
                                                    match(RPAREN)
                                                }
                                            }
                                            else -> throw NoViableAltException(this)
                                        }
                                    }
                                }10 -> {
                                    scoped {
                                        _localctx = TypeCheckContext(ValueContext(_parentctx, _parentState))
                                        pushNewRecursionContext(_localctx, _startState, Rules.RULE_value.id)
                                        this.state = 659

                                        if (!(precpred(context!!, 8))) {
                                            throw FailedPredicateException(this, "precpred(context!!, 8)")
                                        }
                                        this.state = 667
                                        errorHandler.sync(this)

                                        when (_input!!.LA(1)) {
                                            IS  ->  /*LL1AltBlock*/ {
                                                scoped {
                                                    this.state = 660
                                                    match(IS)
                                                    this.state = 661
                                                    typeEx()
                                                }
                                            }LPAREN  ->  /*LL1AltBlock*/ {
                                                scoped {
                                                    this.state = 662
                                                    match(LPAREN)
                                                    this.state = 663
                                                    match(IS)
                                                    this.state = 664
                                                    typeEx()
                                                    this.state = 665
                                                    match(RPAREN)
                                                }
                                            }
                                            else -> throw NoViableAltException(this)
                                        }
                                    }
                                }11 -> {
                                    scoped {
                                        _localctx = SimpleIfContext(ValueContext(_parentctx, _parentState))
                                        pushNewRecursionContext(_localctx, _startState, Rules.RULE_value.id)
                                        this.state = 669

                                        if (!(precpred(context!!, 7))) {
                                            throw FailedPredicateException(this, "precpred(context!!, 7)")
                                        }
                                        this.state = 677
                                        errorHandler.sync(this)

                                        when (_input!!.LA(1)) {
                                            IF  ->  /*LL1AltBlock*/ {
                                                scoped {
                                                    this.state = 670
                                                    match(IF)
                                                    this.state = 671
                                                    value(0)
                                                }
                                            }LPAREN  ->  /*LL1AltBlock*/ {
                                                scoped {
                                                    this.state = 672
                                                    match(LPAREN)
                                                    this.state = 673
                                                    match(IF)
                                                    this.state = 674
                                                    value(0)
                                                    this.state = 675
                                                    match(RPAREN)
                                                }
                                            }
                                            else -> throw NoViableAltException(this)
                                        }
                                    }
                                }
                            }
                        } 
                    }

                    this.state = 683
                    errorHandler.sync(this)
                    _alt = interpreter!!.adaptivePredict(_input!!, 88, context)
                }
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            unrollRecursionContexts(_parentctx)
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class ReferenceContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_reference.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()

        public fun findCommonIdentifier(): CommonIdentifierContext? = getRuleContext(CommonIdentifierContext::class, 0)
        public fun findPackage_(): Package_Context? = getRuleContext(Package_Context::class, 0)
        public fun DOT(): TerminalNode? = getToken(Tokens.DOT.id, 0)

        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterReference(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitReference(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitReference(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun reference(): ReferenceContext {
        var _localctx = ReferenceContext(context, state)
        enterRule(_localctx, 64, Rules.RULE_reference.id)

        try {
            enterOuterAlt(_localctx, 1)
            scoped {
                this.state = 687
                errorHandler.sync(this)

                when (interpreter!!.adaptivePredict(_input!!, 89, context)) {
                    1 -> scoped {
                    this.state = 684
                    package_()
                    this.state = 685
                    match(DOT)
                }
                }
                this.state = 689
                commonIdentifier()
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class TypeCastingContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_typeCasting.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()

        public fun LPAREN(): TerminalNode? = getToken(Tokens.LPAREN.id, 0)
        public fun TILDE(): TerminalNode? = getToken(Tokens.TILDE.id, 0)
        public fun findTypeEx(): TypeExContext? = getRuleContext(TypeExContext::class, 0)
        public fun RPAREN(): TerminalNode? = getToken(Tokens.RPAREN.id, 0)

        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterTypeCasting(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitTypeCasting(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitTypeCasting(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun typeCasting(): TypeCastingContext {
        var _localctx = TypeCastingContext(context, state)
        enterRule(_localctx, 66, Rules.RULE_typeCasting.id)

        try {
            enterOuterAlt(_localctx, 1)
            scoped {
                this.state = 691
                match(LPAREN)
                this.state = 692
                match(TILDE)
                this.state = 693
                typeEx()
                this.state = 694
                match(RPAREN)
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class If_elseContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_if_else.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()

        public fun IF(): TerminalNode? = getToken(Tokens.IF.id, 0)
        public fun LPAREN(): TerminalNode? = getToken(Tokens.LPAREN.id, 0)
        public fun findValue(): List<ValueContext> = getRuleContexts(ValueContext::class)
        public fun findValue(i: Int): ValueContext? = getRuleContext(ValueContext::class, i)
        public fun RPAREN(): TerminalNode? = getToken(Tokens.RPAREN.id, 0)
        public fun ELSE(): TerminalNode? = getToken(Tokens.ELSE.id, 0)

        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterIf_else(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitIf_else(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitIf_else(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun if_else(): If_elseContext {
        var _localctx = If_elseContext(context, state)
        enterRule(_localctx, 68, Rules.RULE_if_else.id)

        try {
            enterOuterAlt(_localctx, 1)
            scoped {
                this.state = 696
                match(IF)
                this.state = 697
                match(LPAREN)
                this.state = 698
                value(0)
                this.state = 699
                match(RPAREN)
                this.state = 700
                value(0)
                this.state = 701
                match(ELSE)
                this.state = 702
                value(0)
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class Let_bindingContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_let_binding.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()

        public fun LET(): TerminalNode? = getToken(Tokens.LET.id, 0)
        public fun findValue(): List<ValueContext> = getRuleContexts(ValueContext::class)
        public fun findValue(i: Int): ValueContext? = getRuleContext(ValueContext::class, i)
        public fun ASSGIN(): TerminalNode? = getToken(Tokens.ASSGIN.id, 0)

        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterLet_binding(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitLet_binding(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitLet_binding(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun let_binding(): Let_bindingContext {
        var _localctx = Let_bindingContext(context, state)
        enterRule(_localctx, 70, Rules.RULE_let_binding.id)

        try {
            enterOuterAlt(_localctx, 1)
            scoped {
                this.state = 704
                match(LET)
                this.state = 705
                value(0)
                this.state = 706
                match(ASSGIN)
                this.state = 707
                value(0)
                this.state = 708
                value(0)
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class PatternMatchContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_patternMatch.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()

        public fun MATCH(): TerminalNode? = getToken(Tokens.MATCH.id, 0)
        public fun findPatternMatchCompo(): List<PatternMatchCompoContext> = getRuleContexts(PatternMatchCompoContext::class)
        public fun findPatternMatchCompo(i: Int): PatternMatchCompoContext? = getRuleContext(PatternMatchCompoContext::class, i)

        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterPatternMatch(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitPatternMatch(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitPatternMatch(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun patternMatch(): PatternMatchContext {
        var _localctx = PatternMatchContext(context, state)
        enterRule(_localctx, 72, Rules.RULE_patternMatch.id)

        try {
            var _alt: Int
            enterOuterAlt(_localctx, 1)
            scoped {
                this.state = 710
                match(MATCH)
                this.state = 712 
                errorHandler.sync(this)
                _alt = 1

                do {
                    when (_alt) {
                        1 -> scoped {
                    scoped {
                        this.state = 711
                        patternMatchCompo()
                    }
                }
                        else -> throw NoViableAltException(this)
                    }

                    this.state = 714 
                    errorHandler.sync(this)
                    _alt = interpreter!!.adaptivePredict(_input!!,90,context)
                } while (_alt != 2 && _alt != INVALID_ALT_NUMBER)
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class PatternMatchCompoContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_patternMatchCompo.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()

        public var patternValue: ValueContext? = null
        public var predicateValue: ValueContext? = null
        public var outputValue: ValueContext? = null
        public fun ARROW(): TerminalNode? = getToken(Tokens.ARROW.id, 0)
        public fun findValue(): List<ValueContext> = getRuleContexts(ValueContext::class)
        public fun findValue(i: Int): ValueContext? = getRuleContext(ValueContext::class, i)
        public fun WHERE(): TerminalNode? = getToken(Tokens.WHERE.id, 0)

        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterPatternMatchCompo(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitPatternMatchCompo(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitPatternMatchCompo(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun patternMatchCompo(): PatternMatchCompoContext {
        var _localctx = PatternMatchCompoContext(context, state)
        enterRule(_localctx, 74, Rules.RULE_patternMatchCompo.id)
        var _la: Int

        try {
            enterOuterAlt(_localctx, 1)
            scoped {
                this.state = 716
                (_localctx as PatternMatchCompoContext).patternValue = value(0)
                this.state = 719
                errorHandler.sync(this)
                _la = _input!!.LA(1)

                if (_la == WHERE) {
                    scoped {
                        this.state = 717
                        match(WHERE)
                        this.state = 718
                        (_localctx as PatternMatchCompoContext).predicateValue = value(0)
                    }
                }
                this.state = 721
                match(ARROW)
                this.state = 722
                (_localctx as PatternMatchCompoContext).outputValue = value(0)
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class TupleExContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_tupleEx.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()

        public fun SHARP(): TerminalNode? = getToken(Tokens.SHARP.id, 0)
        public fun LPAREN(): TerminalNode? = getToken(Tokens.LPAREN.id, 0)
        public fun RPAREN(): TerminalNode? = getToken(Tokens.RPAREN.id, 0)
        public fun findValue(): List<ValueContext> = getRuleContexts(ValueContext::class)
        public fun findValue(i: Int): ValueContext? = getRuleContext(ValueContext::class, i)

        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterTupleEx(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitTupleEx(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitTupleEx(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun tupleEx(): TupleExContext {
        var _localctx = TupleExContext(context, state)
        enterRule(_localctx, 76, Rules.RULE_tupleEx.id)
        var _la: Int

        try {
            enterOuterAlt(_localctx, 1)
            scoped {
                this.state = 724
                match(SHARP)
                this.state = 725
                match(LPAREN)
                this.state = 729
                errorHandler.sync(this)
                _la = _input!!.LA(1)

                while ((((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and -8959315521190219648L) != 0L) || ((((_la - 65)) and 0x3f.inv()) == 0 && ((1L shl (_la - 65)) and 233L) != 0L)) {
                    scoped {
                        scoped {
                            this.state = 726
                            value(0)
                        }
                    }
                    this.state = 731
                    errorHandler.sync(this)
                    _la = _input!!.LA(1)
                }
                this.state = 732
                match(RPAREN)
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class ParamExContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_paramEx.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()

        public fun ID(): TerminalNode? = getToken(Tokens.ID.id, 0)
        public fun ELLIPSIS(): TerminalNode? = getToken(Tokens.ELLIPSIS.id, 0)
        public fun TILDE(): TerminalNode? = getToken(Tokens.TILDE.id, 0)
        public fun findTypeEx(): TypeExContext? = getRuleContext(TypeExContext::class, 0)
        public fun findValue(): ValueContext? = getRuleContext(ValueContext::class, 0)
        public fun ARROW(): TerminalNode? = getToken(Tokens.ARROW.id, 0)
        public fun QM(): TerminalNode? = getToken(Tokens.QM.id, 0)
        public fun ARROWQM(): TerminalNode? = getToken(Tokens.ARROWQM.id, 0)

        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterParamEx(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitParamEx(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitParamEx(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun paramEx(): ParamExContext {
        var _localctx = ParamExContext(context, state)
        enterRule(_localctx, 78, Rules.RULE_paramEx.id)

        try {
            this.state = 756
            errorHandler.sync(this)

            when (interpreter!!.adaptivePredict(_input!!, 94, context)) {
                1 -> {
                    enterOuterAlt(_localctx, 1)
                    scoped {
                        this.state = 734
                        match(ID)
                        this.state = 735
                        match(ELLIPSIS)
                        this.state = 736
                        match(TILDE)
                        this.state = 737
                        typeEx()
                    }
                }2 -> {
                    enterOuterAlt(_localctx, 2)
                    scoped {
                        this.state = 738
                        match(ID)
                        this.state = 739
                        match(TILDE)
                        this.state = 740
                        typeEx()
                    }
                }3 -> {
                    enterOuterAlt(_localctx, 3)
                    scoped {
                        this.state = 741
                        value(0)
                        this.state = 745
                        errorHandler.sync(this)

                        when (_input!!.LA(1)) {
                            ARROW  ->  /*LL1AltBlock*/ {
                                scoped {
                                    this.state = 742
                                    match(ARROW)
                                    this.state = 743
                                    match(QM)
                                }
                            }ARROWQM  ->  /*LL1AltBlock*/ {
                                scoped {
                                    this.state = 744
                                    match(ARROWQM)
                                }
                            }
                            else -> throw NoViableAltException(this)
                        }
                        this.state = 747
                        match(TILDE)
                        this.state = 748
                        typeEx()
                    }
                }4 -> {
                    enterOuterAlt(_localctx, 4)
                    scoped {
                        this.state = 750
                        value(0)
                        this.state = 751
                        match(ARROW)
                        this.state = 752
                        match(ID)
                        this.state = 753
                        match(TILDE)
                        this.state = 754
                        typeEx()
                    }
                }
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class ParameterContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_parameter.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()

        public fun findParamEx(): List<ParamExContext> = getRuleContexts(ParamExContext::class)
        public fun findParamEx(i: Int): ParamExContext? = getRuleContext(ParamExContext::class, i)

        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterParameter(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitParameter(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitParameter(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun parameter(): ParameterContext {
        var _localctx = ParameterContext(context, state)
        enterRule(_localctx, 80, Rules.RULE_parameter.id)
        var _la: Int

        try {
            enterOuterAlt(_localctx, 1)
            scoped {
                this.state = 759 
                errorHandler.sync(this)
                _la = _input!!.LA(1)

                do {
                    scoped {
                        scoped {
                            this.state = 758
                            paramEx()
                        }
                    }
                    this.state = 761 
                    errorHandler.sync(this)
                    _la = _input!!.LA(1)
                } while ((((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and -8959315521190219648L) != 0L) || ((((_la - 65)) and 0x3f.inv()) == 0 && ((1L shl (_la - 65)) and 233L) != 0L))
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class ArgExContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_argEx.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()


        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

     
        public constructor() : super()

        public fun copyFrom(ctx: ArgExContext) {
            super.copyFrom(ctx)
        }

    }

    public open class SingleArgContext : ArgExContext {
        public fun findValue(): ValueContext? = getRuleContext(ValueContext::class, 0)
        public fun ID(): TerminalNode? = getToken(Tokens.ID.id, 0)
        public fun ASSGIN(): TerminalNode? = getToken(Tokens.ASSGIN.id, 0)
        public fun ELLIPSIS(): TerminalNode? = getToken(Tokens.ELLIPSIS.id, 0)

        public constructor(ctx: ArgExContext) {
            copyFrom(ctx)
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterSingleArg(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitSingleArg(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitSingleArg(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }

    public open class MultiArgContext : ArgExContext {
        public fun LBRACE(): TerminalNode? = getToken(Tokens.LBRACE.id, 0)
        public fun RBRACE(): TerminalNode? = getToken(Tokens.RBRACE.id, 0)
        public fun ID(): TerminalNode? = getToken(Tokens.ID.id, 0)
        public fun ELLIPSIS(): TerminalNode? = getToken(Tokens.ELLIPSIS.id, 0)
        public fun findValue(): List<ValueContext> = getRuleContexts(ValueContext::class)
        public fun findValue(i: Int): ValueContext? = getRuleContext(ValueContext::class, i)

        public constructor(ctx: ArgExContext) {
            copyFrom(ctx)
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterMultiArg(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitMultiArg(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitMultiArg(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun argEx(): ArgExContext {
        var _localctx = ArgExContext(context, state)
        enterRule(_localctx, 82, Rules.RULE_argEx.id)
        var _la: Int

        try {
            this.state = 783
            errorHandler.sync(this)

            when (interpreter!!.adaptivePredict(_input!!, 100, context)) {
                1 -> {
                    _localctx = SingleArgContext(_localctx)
                    enterOuterAlt(_localctx, 1)
                    scoped {
                        this.state = 765
                        errorHandler.sync(this)

                        when (interpreter!!.adaptivePredict(_input!!, 96, context)) {
                            1 -> scoped {
                            this.state = 763
                            match(ID)
                            this.state = 764
                            match(ASSGIN)
                        }
                        }
                        this.state = 768
                        errorHandler.sync(this)
                        _la = _input!!.LA(1)

                        if (_la == ELLIPSIS) {
                            scoped {
                                this.state = 767
                                match(ELLIPSIS)
                            }
                        }
                        this.state = 770
                        value(0)
                    }
                }2 -> {
                    _localctx = MultiArgContext(_localctx)
                    enterOuterAlt(_localctx, 2)
                    scoped {
                        this.state = 773
                        errorHandler.sync(this)
                        _la = _input!!.LA(1)

                        if (_la == ID) {
                            scoped {
                                this.state = 771
                                match(ID)
                                this.state = 772
                                match(ELLIPSIS)
                            }
                        }
                        this.state = 775
                        match(LBRACE)
                        this.state = 779
                        errorHandler.sync(this)
                        _la = _input!!.LA(1)

                        while ((((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and -8959315521190219648L) != 0L) || ((((_la - 65)) and 0x3f.inv()) == 0 && ((1L shl (_la - 65)) and 233L) != 0L)) {
                            scoped {
                                scoped {
                                    this.state = 776
                                    value(0)
                                }
                            }
                            this.state = 781
                            errorHandler.sync(this)
                            _la = _input!!.LA(1)
                        }
                        this.state = 782
                        match(RBRACE)
                    }
                }
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class ArgValueContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_argValue.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()


        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

     
        public constructor() : super()

        public fun copyFrom(ctx: ArgValueContext) {
            super.copyFrom(ctx)
        }

    }

    public open class SingleListArgValueContext : ArgValueContext {
        public fun LBRACE(): TerminalNode? = getToken(Tokens.LBRACE.id, 0)
        public fun RBRACE(): TerminalNode? = getToken(Tokens.RBRACE.id, 0)
        public fun PIPE(): TerminalNode? = getToken(Tokens.PIPE.id, 0)
        public fun findValue(): List<ValueContext> = getRuleContexts(ValueContext::class)
        public fun findValue(i: Int): ValueContext? = getRuleContext(ValueContext::class, i)
        public fun findTypeEx(): List<TypeExContext> = getRuleContexts(TypeExContext::class)
        public fun findTypeEx(i: Int): TypeExContext? = getRuleContext(TypeExContext::class, i)

        public constructor(ctx: ArgValueContext) {
            copyFrom(ctx)
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterSingleListArgValue(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitSingleListArgValue(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitSingleListArgValue(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }

    public open class PrimaryArgValueContext : ArgValueContext {
        public fun LPAREN(): TerminalNode? = getToken(Tokens.LPAREN.id, 0)
        public fun RPAREN(): TerminalNode? = getToken(Tokens.RPAREN.id, 0)
        public fun PIPE(): TerminalNode? = getToken(Tokens.PIPE.id, 0)
        public fun findArgEx(): List<ArgExContext> = getRuleContexts(ArgExContext::class)
        public fun findArgEx(i: Int): ArgExContext? = getRuleContext(ArgExContext::class, i)
        public fun findTypeEx(): List<TypeExContext> = getRuleContexts(TypeExContext::class)
        public fun findTypeEx(i: Int): TypeExContext? = getRuleContext(TypeExContext::class, i)

        public constructor(ctx: ArgValueContext) {
            copyFrom(ctx)
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterPrimaryArgValue(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitPrimaryArgValue(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitPrimaryArgValue(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun argValue(): ArgValueContext {
        var _localctx = ArgValueContext(context, state)
        enterRule(_localctx, 84, Rules.RULE_argValue.id)
        var _la: Int

        try {
            this.state = 819
            errorHandler.sync(this)

            when (_input!!.LA(1)) {
                LPAREN  ->  /*LL1AltBlock*/ {
                    _localctx = PrimaryArgValueContext(_localctx)
                    enterOuterAlt(_localctx, 1)
                    scoped {
                        this.state = 785
                        match(LPAREN)
                        this.state = 793
                        errorHandler.sync(this)

                        when (interpreter!!.adaptivePredict(_input!!, 102, context)) {
                            1 -> scoped {
                            this.state = 789
                            errorHandler.sync(this)
                            _la = _input!!.LA(1)

                            while (((((_la - 32)) and 0x3f.inv()) == 0 && ((1L shl (_la - 32)) and 70869189119L) != 0L)) {
                                scoped {
                                    scoped {
                                        this.state = 786
                                        typeEx()
                                    }
                                }
                                this.state = 791
                                errorHandler.sync(this)
                                _la = _input!!.LA(1)
                            }
                            this.state = 792
                            match(PIPE)
                        }
                        }
                        this.state = 798
                        errorHandler.sync(this)
                        _la = _input!!.LA(1)

                        while ((((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and -8959174783701864320L) != 0L) || ((((_la - 65)) and 0x3f.inv()) == 0 && ((1L shl (_la - 65)) and 233L) != 0L)) {
                            scoped {
                                scoped {
                                    this.state = 795
                                    argEx()
                                }
                            }
                            this.state = 800
                            errorHandler.sync(this)
                            _la = _input!!.LA(1)
                        }
                        this.state = 801
                        match(RPAREN)
                    }
                }LBRACE  ->  /*LL1AltBlock*/ {
                    _localctx = SingleListArgValueContext(_localctx)
                    enterOuterAlt(_localctx, 2)
                    scoped {
                        this.state = 802
                        match(LBRACE)
                        this.state = 810
                        errorHandler.sync(this)

                        when (interpreter!!.adaptivePredict(_input!!, 105, context)) {
                            1 -> scoped {
                            this.state = 806
                            errorHandler.sync(this)
                            _la = _input!!.LA(1)

                            while (((((_la - 32)) and 0x3f.inv()) == 0 && ((1L shl (_la - 32)) and 70869189119L) != 0L)) {
                                scoped {
                                    scoped {
                                        this.state = 803
                                        typeEx()
                                    }
                                }
                                this.state = 808
                                errorHandler.sync(this)
                                _la = _input!!.LA(1)
                            }
                            this.state = 809
                            match(PIPE)
                        }
                        }
                        this.state = 815
                        errorHandler.sync(this)
                        _la = _input!!.LA(1)

                        while ((((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and -8959315521190219648L) != 0L) || ((((_la - 65)) and 0x3f.inv()) == 0 && ((1L shl (_la - 65)) and 233L) != 0L)) {
                            scoped {
                                scoped {
                                    this.state = 812
                                    value(0)
                                }
                            }
                            this.state = 817
                            errorHandler.sync(this)
                            _la = _input!!.LA(1)
                        }
                        this.state = 818
                        match(RBRACE)
                    }
                }
                else -> throw NoViableAltException(this)
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class InvokingContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_invoking.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()

        public fun COLON(): TerminalNode? = getToken(Tokens.COLON.id, 0)
        public fun LPAREN(): TerminalNode? = getToken(Tokens.LPAREN.id, 0)
        public fun RPAREN(): TerminalNode? = getToken(Tokens.RPAREN.id, 0)
        public fun findValue(): List<ValueContext> = getRuleContexts(ValueContext::class)
        public fun findValue(i: Int): ValueContext? = getRuleContext(ValueContext::class, i)

        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterInvoking(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitInvoking(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitInvoking(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun invoking(): InvokingContext {
        var _localctx = InvokingContext(context, state)
        enterRule(_localctx, 86, Rules.RULE_invoking.id)
        var _la: Int

        try {
            enterOuterAlt(_localctx, 1)
            scoped {
                this.state = 821
                match(COLON)
                this.state = 822
                match(LPAREN)
                this.state = 826
                errorHandler.sync(this)
                _la = _input!!.LA(1)

                while ((((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and -8959315521190219648L) != 0L) || ((((_la - 65)) and 0x3f.inv()) == 0 && ((1L shl (_la - 65)) and 233L) != 0L)) {
                    scoped {
                        scoped {
                            this.state = 823
                            value(0)
                        }
                    }
                    this.state = 828
                    errorHandler.sync(this)
                    _la = _input!!.LA(1)
                }
                this.state = 829
                match(RPAREN)
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class CommonOpIdentifierContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_commonOpIdentifier.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()

        public fun OPID(): TerminalNode? = getToken(Tokens.OPID.id, 0)
        public fun findCommonIdentifier(): CommonIdentifierContext? = getRuleContext(CommonIdentifierContext::class, 0)
        public fun EM(): TerminalNode? = getToken(Tokens.EM.id, 0)

        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterCommonOpIdentifier(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitCommonOpIdentifier(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitCommonOpIdentifier(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun commonOpIdentifier(): CommonOpIdentifierContext {
        var _localctx = CommonOpIdentifierContext(context, state)
        enterRule(_localctx, 88, Rules.RULE_commonOpIdentifier.id)

        try {
            this.state = 835
            errorHandler.sync(this)

            when (_input!!.LA(1)) {
                OPID  ->  /*LL1AltBlock*/ {
                    enterOuterAlt(_localctx, 1)
                    scoped {
                        this.state = 831
                        match(OPID)
                    }
                }LSQUARE , ID  ->  /*LL1AltBlock*/ {
                    enterOuterAlt(_localctx, 2)
                    scoped {
                        this.state = 832
                        commonIdentifier()
                        this.state = 833
                        match(EM)
                    }
                }
                else -> throw NoViableAltException(this)
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class CommonIdentifierContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_commonIdentifier.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()

        public fun ID(): TerminalNode? = getToken(Tokens.ID.id, 0)
        public fun findOpIdWrap(): OpIdWrapContext? = getRuleContext(OpIdWrapContext::class, 0)
        public fun findAopIdWrap(): AopIdWrapContext? = getRuleContext(AopIdWrapContext::class, 0)

        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterCommonIdentifier(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitCommonIdentifier(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitCommonIdentifier(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun commonIdentifier(): CommonIdentifierContext {
        var _localctx = CommonIdentifierContext(context, state)
        enterRule(_localctx, 90, Rules.RULE_commonIdentifier.id)

        try {
            this.state = 840
            errorHandler.sync(this)

            when (interpreter!!.adaptivePredict(_input!!, 110, context)) {
                1 -> {
                    enterOuterAlt(_localctx, 1)
                    scoped {
                        this.state = 837
                        match(ID)
                    }
                }2 -> {
                    enterOuterAlt(_localctx, 2)
                    scoped {
                        this.state = 838
                        opIdWrap()
                    }
                }3 -> {
                    enterOuterAlt(_localctx, 3)
                    scoped {
                        this.state = 839
                        aopIdWrap()
                    }
                }
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class OpIdWrapContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_opIdWrap.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()

        public fun LSQUARE(): TerminalNode? = getToken(Tokens.LSQUARE.id, 0)
        public fun OPID(): TerminalNode? = getToken(Tokens.OPID.id, 0)
        public fun RSQUARE(): TerminalNode? = getToken(Tokens.RSQUARE.id, 0)

        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterOpIdWrap(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitOpIdWrap(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitOpIdWrap(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun opIdWrap(): OpIdWrapContext {
        var _localctx = OpIdWrapContext(context, state)
        enterRule(_localctx, 92, Rules.RULE_opIdWrap.id)

        try {
            enterOuterAlt(_localctx, 1)
            scoped {
                this.state = 842
                match(LSQUARE)
                this.state = 843
                match(OPID)
                this.state = 844
                match(RSQUARE)
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class AopIdWrapContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_aopIdWrap.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()

        public fun LSQUARE(): TerminalNode? = getToken(Tokens.LSQUARE.id, 0)
        public fun TILDE(): TerminalNode? = getToken(Tokens.TILDE.id, 0)
        public fun OPID(): TerminalNode? = getToken(Tokens.OPID.id, 0)
        public fun RSQUARE(): TerminalNode? = getToken(Tokens.RSQUARE.id, 0)

        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterAopIdWrap(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitAopIdWrap(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitAopIdWrap(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun aopIdWrap(): AopIdWrapContext {
        var _localctx = AopIdWrapContext(context, state)
        enterRule(_localctx, 94, Rules.RULE_aopIdWrap.id)

        try {
            enterOuterAlt(_localctx, 1)
            scoped {
                this.state = 846
                match(LSQUARE)
                this.state = 847
                match(TILDE)
                this.state = 848
                match(OPID)
                this.state = 849
                match(RSQUARE)
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class CommonClassIdentifierContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_commonClassIdentifier.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()

        public fun ID(): TerminalNode? = getToken(Tokens.ID.id, 0)
        public fun QUOTE(): List<TerminalNode> = getTokens(Tokens.QUOTE.id)
        public fun QUOTE(i: Int): TerminalNode = getToken(Tokens.QUOTE.id, i)!!

        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterCommonClassIdentifier(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitCommonClassIdentifier(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitCommonClassIdentifier(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun commonClassIdentifier(): CommonClassIdentifierContext {
        var _localctx = CommonClassIdentifierContext(context, state)
        enterRule(_localctx, 96, Rules.RULE_commonClassIdentifier.id)

        try {
            this.state = 855
            errorHandler.sync(this)

            when (_input!!.LA(1)) {
                ID  ->  /*LL1AltBlock*/ {
                    enterOuterAlt(_localctx, 1)
                    scoped {
                        this.state = 851
                        match(ID)
                    }
                }QUOTE  ->  /*LL1AltBlock*/ {
                    enterOuterAlt(_localctx, 2)
                    scoped {
                        this.state = 852
                        match(QUOTE)
                        this.state = 853
                        match(ID)
                        this.state = 854
                        match(QUOTE)
                    }
                }
                else -> throw NoViableAltException(this)
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class FieldContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_field.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()

        public fun findFieldSetted(): FieldSettedContext? = getRuleContext(FieldSettedContext::class, 0)
        public fun findFieldNotInit(): FieldNotInitContext? = getRuleContext(FieldNotInitContext::class, 0)
        public fun findForeignField(): ForeignFieldContext? = getRuleContext(ForeignFieldContext::class, 0)

        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterField(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitField(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitField(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun field(): FieldContext {
        var _localctx = FieldContext(context, state)
        enterRule(_localctx, 98, Rules.RULE_field.id)

        try {
            this.state = 860
            errorHandler.sync(this)

            when (interpreter!!.adaptivePredict(_input!!, 112, context)) {
                1 -> {
                    enterOuterAlt(_localctx, 1)
                    scoped {
                        this.state = 857
                        fieldSetted()
                    }
                }2 -> {
                    enterOuterAlt(_localctx, 2)
                    scoped {
                        this.state = 858
                        fieldNotInit()
                    }
                }3 -> {
                    enterOuterAlt(_localctx, 3)
                    scoped {
                        this.state = 859
                        foreignField()
                    }
                }
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class FieldNotInitContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_fieldNotInit.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()

        public fun ID(): TerminalNode? = getToken(Tokens.ID.id, 0)
        public fun findTypeEx(): TypeExContext? = getRuleContext(TypeExContext::class, 0)
        public fun LPAREN(): TerminalNode? = getToken(Tokens.LPAREN.id, 0)
        public fun MUTABLE(): TerminalNode? = getToken(Tokens.MUTABLE.id, 0)
        public fun RPAREN(): TerminalNode? = getToken(Tokens.RPAREN.id, 0)

        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterFieldNotInit(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitFieldNotInit(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitFieldNotInit(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun fieldNotInit(): FieldNotInitContext {
        var _localctx = FieldNotInitContext(context, state)
        enterRule(_localctx, 100, Rules.RULE_fieldNotInit.id)
        var _la: Int

        try {
            enterOuterAlt(_localctx, 1)
            scoped {
                this.state = 865
                errorHandler.sync(this)
                _la = _input!!.LA(1)

                if (_la == LPAREN) {
                    scoped {
                        this.state = 862
                        match(LPAREN)
                        this.state = 863
                        match(MUTABLE)
                        this.state = 864
                        match(RPAREN)
                    }
                }
                this.state = 867
                match(ID)
                this.state = 868
                typeEx()
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class FieldSettedContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_fieldSetted.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()

        public fun ID(): TerminalNode? = getToken(Tokens.ID.id, 0)
        public fun findTypeEx(): TypeExContext? = getRuleContext(TypeExContext::class, 0)
        public fun ASSGIN(): TerminalNode? = getToken(Tokens.ASSGIN.id, 0)
        public fun findValue(): ValueContext? = getRuleContext(ValueContext::class, 0)
        public fun LPAREN(): TerminalNode? = getToken(Tokens.LPAREN.id, 0)
        public fun MUTABLE(): TerminalNode? = getToken(Tokens.MUTABLE.id, 0)
        public fun RPAREN(): TerminalNode? = getToken(Tokens.RPAREN.id, 0)

        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterFieldSetted(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitFieldSetted(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitFieldSetted(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun fieldSetted(): FieldSettedContext {
        var _localctx = FieldSettedContext(context, state)
        enterRule(_localctx, 102, Rules.RULE_fieldSetted.id)
        var _la: Int

        try {
            enterOuterAlt(_localctx, 1)
            scoped {
                this.state = 873
                errorHandler.sync(this)
                _la = _input!!.LA(1)

                if (_la == LPAREN) {
                    scoped {
                        this.state = 870
                        match(LPAREN)
                        this.state = 871
                        match(MUTABLE)
                        this.state = 872
                        match(RPAREN)
                    }
                }
                this.state = 875
                match(ID)
                this.state = 876
                typeEx()
                this.state = 877
                match(ASSGIN)
                this.state = 878
                value(0)
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class ForeignFieldContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_foreignField.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()

        public var gettingValue: ValueContext? = null
        public var inputID: Token? = null
        public var settingValue: ValueContext? = null
        public fun LPAREN(): TerminalNode? = getToken(Tokens.LPAREN.id, 0)
        public fun FOREIGN(): TerminalNode? = getToken(Tokens.FOREIGN.id, 0)
        public fun RPAREN(): TerminalNode? = getToken(Tokens.RPAREN.id, 0)
        public fun ID(): List<TerminalNode> = getTokens(Tokens.ID.id)
        public fun ID(i: Int): TerminalNode = getToken(Tokens.ID.id, i)!!
        public fun findTypeEx(): TypeExContext? = getRuleContext(TypeExContext::class, 0)
        public fun GET(): TerminalNode? = getToken(Tokens.GET.id, 0)
        public fun ASSGIN(): List<TerminalNode> = getTokens(Tokens.ASSGIN.id)
        public fun ASSGIN(i: Int): TerminalNode = getToken(Tokens.ASSGIN.id, i)!!
        public fun SET(): TerminalNode? = getToken(Tokens.SET.id, 0)
        public fun findValue(): List<ValueContext> = getRuleContexts(ValueContext::class)
        public fun findValue(i: Int): ValueContext? = getRuleContext(ValueContext::class, i)

        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterForeignField(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitForeignField(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitForeignField(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun foreignField(): ForeignFieldContext {
        var _localctx = ForeignFieldContext(context, state)
        enterRule(_localctx, 104, Rules.RULE_foreignField.id)

        try {
            enterOuterAlt(_localctx, 1)
            scoped {
                this.state = 880
                match(LPAREN)
                this.state = 881
                match(FOREIGN)
                this.state = 882
                match(RPAREN)
                this.state = 883
                match(ID)
                this.state = 884
                typeEx()
                this.state = 888
                errorHandler.sync(this)

                when (interpreter!!.adaptivePredict(_input!!, 115, context)) {
                    1 -> scoped {
                    this.state = 885
                    match(GET)
                    this.state = 886
                    match(ASSGIN)
                    this.state = 887
                    (_localctx as ForeignFieldContext).gettingValue = value(0)
                }
                }
                this.state = 894
                errorHandler.sync(this)

                when (interpreter!!.adaptivePredict(_input!!, 116, context)) {
                    1 -> scoped {
                    this.state = 890
                    match(SET)
                    this.state = 891
                    (_localctx as ForeignFieldContext).inputID = match(ID)
                    this.state = 892
                    match(ASSGIN)
                    this.state = 893
                    (_localctx as ForeignFieldContext).settingValue = value(0)
                }
                }
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class DefContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_def.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()

        public fun findJustDef(): JustDefContext? = getRuleContext(JustDefContext::class, 0)
        public fun findInverseDefining(): List<InverseDefiningContext> = getRuleContexts(InverseDefiningContext::class)
        public fun findInverseDefining(i: Int): InverseDefiningContext? = getRuleContext(InverseDefiningContext::class, i)
        public fun findForeignDef(): ForeignDefContext? = getRuleContext(ForeignDefContext::class, 0)

        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterDef(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitDef(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitDef(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun def(): DefContext {
        var _localctx = DefContext(context, state)
        enterRule(_localctx, 106, Rules.RULE_def.id)

        try {
            var _alt: Int
            this.state = 910
            errorHandler.sync(this)

            when (interpreter!!.adaptivePredict(_input!!, 119, context)) {
                1 -> {
                    enterOuterAlt(_localctx, 1)
                    scoped {
                        this.state = 896
                        justDef()
                        this.state = 900
                        errorHandler.sync(this)
                        _alt = interpreter!!.adaptivePredict(_input!!,117,context)

                        while (_alt != 2 && _alt != INVALID_ALT_NUMBER) {
                            if (_alt == 1 ) {
                                scoped {
                                    scoped {
                                        this.state = 897
                                        inverseDefining()
                                    }
                                } 
                            }

                            this.state = 902
                            errorHandler.sync(this)
                            _alt = interpreter!!.adaptivePredict(_input!!, 117, context)
                        }
                    }
                }2 -> {
                    enterOuterAlt(_localctx, 2)
                    scoped {
                        this.state = 903
                        foreignDef()
                        this.state = 907
                        errorHandler.sync(this)
                        _alt = interpreter!!.adaptivePredict(_input!!,118,context)

                        while (_alt != 2 && _alt != INVALID_ALT_NUMBER) {
                            if (_alt == 1 ) {
                                scoped {
                                    scoped {
                                        this.state = 904
                                        inverseDefining()
                                    }
                                } 
                            }

                            this.state = 909
                            errorHandler.sync(this)
                            _alt = interpreter!!.adaptivePredict(_input!!, 118, context)
                        }
                    }
                }
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class JustDefContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_justDef.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()

        public fun findCommonIdentifier(): CommonIdentifierContext? = getRuleContext(CommonIdentifierContext::class, 0)
        public fun findTypeEx(): TypeExContext? = getRuleContext(TypeExContext::class, 0)
        public fun ASSGIN(): TerminalNode? = getToken(Tokens.ASSGIN.id, 0)
        public fun findValue(): ValueContext? = getRuleContext(ValueContext::class, 0)
        public fun findAnnotationBlock(): AnnotationBlockContext? = getRuleContext(AnnotationBlockContext::class, 0)
        public fun findTypeParam(): TypeParamContext? = getRuleContext(TypeParamContext::class, 0)
        public fun LPAREN(): TerminalNode? = getToken(Tokens.LPAREN.id, 0)
        public fun findParameter(): ParameterContext? = getRuleContext(ParameterContext::class, 0)
        public fun RPAREN(): TerminalNode? = getToken(Tokens.RPAREN.id, 0)

        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterJustDef(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitJustDef(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitJustDef(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun justDef(): JustDefContext {
        var _localctx = JustDefContext(context, state)
        enterRule(_localctx, 108, Rules.RULE_justDef.id)

        try {
            enterOuterAlt(_localctx, 1)
            scoped {
                this.state = 913
                errorHandler.sync(this)

                when (interpreter!!.adaptivePredict(_input!!, 120, context)) {
                    1 -> scoped {
                    this.state = 912
                    annotationBlock()
                }
                }
                this.state = 915
                commonIdentifier()
                this.state = 917
                errorHandler.sync(this)

                when (interpreter!!.adaptivePredict(_input!!, 121, context)) {
                    1 -> scoped {
                    this.state = 916
                    typeParam()
                }
                }
                this.state = 923
                errorHandler.sync(this)

                when (interpreter!!.adaptivePredict(_input!!, 122, context)) {
                    1 -> scoped {
                    this.state = 919
                    match(LPAREN)
                    this.state = 920
                    parameter()
                    this.state = 921
                    match(RPAREN)
                }
                }
                this.state = 925
                typeEx()
                this.state = 926
                match(ASSGIN)
                this.state = 927
                value(0)
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class ForeignDefContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_foreignDef.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()

        public fun findCommonIdentifier(): CommonIdentifierContext? = getRuleContext(CommonIdentifierContext::class, 0)
        public fun FOREIGN(): TerminalNode? = getToken(Tokens.FOREIGN.id, 0)
        public fun findTypeEx(): TypeExContext? = getRuleContext(TypeExContext::class, 0)
        public fun findAnnotationBlock(): AnnotationBlockContext? = getRuleContext(AnnotationBlockContext::class, 0)
        public fun findTypeParam(): TypeParamContext? = getRuleContext(TypeParamContext::class, 0)
        public fun LPAREN(): TerminalNode? = getToken(Tokens.LPAREN.id, 0)
        public fun findParameter(): ParameterContext? = getRuleContext(ParameterContext::class, 0)
        public fun RPAREN(): TerminalNode? = getToken(Tokens.RPAREN.id, 0)
        public fun findForeignBody(): ForeignBodyContext? = getRuleContext(ForeignBodyContext::class, 0)

        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterForeignDef(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitForeignDef(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitForeignDef(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun foreignDef(): ForeignDefContext {
        var _localctx = ForeignDefContext(context, state)
        enterRule(_localctx, 110, Rules.RULE_foreignDef.id)
        var _la: Int

        try {
            enterOuterAlt(_localctx, 1)
            scoped {
                this.state = 930
                errorHandler.sync(this)

                when (interpreter!!.adaptivePredict(_input!!, 123, context)) {
                    1 -> scoped {
                    this.state = 929
                    annotationBlock()
                }
                }
                this.state = 932
                commonIdentifier()
                this.state = 934
                errorHandler.sync(this)
                _la = _input!!.LA(1)

                if (_la == QUOTE || _la == ID) {
                    scoped {
                        this.state = 933
                        typeParam()
                    }
                }
                this.state = 940
                errorHandler.sync(this)
                _la = _input!!.LA(1)

                if (_la == LPAREN) {
                    scoped {
                        this.state = 936
                        match(LPAREN)
                        this.state = 937
                        parameter()
                        this.state = 938
                        match(RPAREN)
                    }
                }
                this.state = 942
                match(FOREIGN)
                this.state = 943
                typeEx()
                this.state = 945
                errorHandler.sync(this)

                when (interpreter!!.adaptivePredict(_input!!, 126, context)) {
                    1 -> scoped {
                    this.state = 944
                    foreignBody()
                }
                }
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class InverseDefiningContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_inverseDefining.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()


        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

     
        public constructor() : super()

        public fun copyFrom(ctx: InverseDefiningContext) {
            super.copyFrom(ctx)
        }

    }

    public open class RawInverseDefContext : InverseDefiningContext {
        public fun INVERSE(): TerminalNode? = getToken(Tokens.INVERSE.id, 0)
        public fun LPAREN(): TerminalNode? = getToken(Tokens.LPAREN.id, 0)
        public fun RPAREN(): TerminalNode? = getToken(Tokens.RPAREN.id, 0)
        public fun findValue(): ValueContext? = getRuleContext(ValueContext::class, 0)
        public fun ID(): TerminalNode? = getToken(Tokens.ID.id, 0)
        public fun findInverseDefGateCompo(): List<InverseDefGateCompoContext> = getRuleContexts(InverseDefGateCompoContext::class)
        public fun findInverseDefGateCompo(i: Int): InverseDefGateCompoContext? = getRuleContext(InverseDefGateCompoContext::class, i)

        public constructor(ctx: InverseDefiningContext) {
            copyFrom(ctx)
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterRawInverseDef(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitRawInverseDef(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitRawInverseDef(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }

    public open class SimpleInverseDefContext : InverseDefiningContext {
        public fun INVERSE(): TerminalNode? = getToken(Tokens.INVERSE.id, 0)
        public fun LPAREN(): TerminalNode? = getToken(Tokens.LPAREN.id, 0)
        public fun RPAREN(): TerminalNode? = getToken(Tokens.RPAREN.id, 0)
        public fun ID(): TerminalNode? = getToken(Tokens.ID.id, 0)
        public fun findInverseDefCompo(): List<InverseDefCompoContext> = getRuleContexts(InverseDefCompoContext::class)
        public fun findInverseDefCompo(i: Int): InverseDefCompoContext? = getRuleContext(InverseDefCompoContext::class, i)

        public constructor(ctx: InverseDefiningContext) {
            copyFrom(ctx)
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterSimpleInverseDef(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitSimpleInverseDef(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitSimpleInverseDef(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun inverseDefining(): InverseDefiningContext {
        var _localctx = InverseDefiningContext(context, state)
        enterRule(_localctx, 112, Rules.RULE_inverseDefining.id)
        var _la: Int

        try {
            this.state = 972
            errorHandler.sync(this)

            when (interpreter!!.adaptivePredict(_input!!, 131, context)) {
                1 -> {
                    _localctx = SimpleInverseDefContext(_localctx)
                    enterOuterAlt(_localctx, 1)
                    scoped {
                        this.state = 947
                        match(INVERSE)
                        this.state = 949
                        errorHandler.sync(this)
                        _la = _input!!.LA(1)

                        if (_la == ID) {
                            scoped {
                                this.state = 948
                                match(ID)
                            }
                        }
                        this.state = 951
                        match(LPAREN)
                        this.state = 953 
                        errorHandler.sync(this)
                        _la = _input!!.LA(1)

                        do {
                            scoped {
                                scoped {
                                    this.state = 952
                                    inverseDefCompo()
                                }
                            }
                            this.state = 955 
                            errorHandler.sync(this)
                            _la = _input!!.LA(1)
                        } while ((((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and -8671085145038507904L) != 0L) || ((((_la - 65)) and 0x3f.inv()) == 0 && ((1L shl (_la - 65)) and 233L) != 0L))
                        this.state = 957
                        match(RPAREN)
                    }
                }2 -> {
                    _localctx = RawInverseDefContext(_localctx)
                    enterOuterAlt(_localctx, 2)
                    scoped {
                        this.state = 959
                        match(INVERSE)
                        this.state = 961
                        errorHandler.sync(this)
                        _la = _input!!.LA(1)

                        if (_la == ID) {
                            scoped {
                                this.state = 960
                                match(ID)
                            }
                        }
                        this.state = 963
                        match(LPAREN)
                        this.state = 965 
                        errorHandler.sync(this)
                        _la = _input!!.LA(1)

                        do {
                            scoped {
                                scoped {
                                    this.state = 964
                                    inverseDefGateCompo()
                                }
                            }
                            this.state = 967 
                            errorHandler.sync(this)
                            _la = _input!!.LA(1)
                        } while ((((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and 396316767208603648L) != 0L))
                        this.state = 969
                        match(RPAREN)
                        this.state = 970
                        value(0)
                    }
                }
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class InverseDefCompoContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_inverseDefCompo.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()


        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

     
        public constructor() : super()

        public fun copyFrom(ctx: InverseDefCompoContext) {
            super.copyFrom(ctx)
        }

    }

    public open class NecessaryParamContext : InverseDefCompoContext {
        public fun As(): TerminalNode? = getToken(Tokens.As.id, 0)
        public fun ID(): TerminalNode? = getToken(Tokens.ID.id, 0)

        public constructor(ctx: InverseDefCompoContext) {
            copyFrom(ctx)
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterNecessaryParam(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitNecessaryParam(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitNecessaryParam(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }

    public open class OutputParamContext : InverseDefCompoContext {
        public fun findValue(): ValueContext? = getRuleContext(ValueContext::class, 0)
        public fun TILDE(): TerminalNode? = getToken(Tokens.TILDE.id, 0)
        public fun findTypeEx(): TypeExContext? = getRuleContext(TypeExContext::class, 0)

        public constructor(ctx: InverseDefCompoContext) {
            copyFrom(ctx)
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterOutputParam(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitOutputParam(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitOutputParam(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun inverseDefCompo(): InverseDefCompoContext {
        var _localctx = InverseDefCompoContext(context, state)
        enterRule(_localctx, 114, Rules.RULE_inverseDefCompo.id)

        try {
            this.state = 981
            errorHandler.sync(this)

            when (_input!!.LA(1)) {
                DO , IMPL , INHERIT , IF , NEW , LET , MATCH , NULLKEYWORD , TRUE , FALSE , THIS , LPAREN , LSQUARE , LBRACE , ARROW , ARROWQM , TILDE , QUOTE , SHARP , ID , Integer , Double , String  ->  /*LL1AltBlock*/ {
                    _localctx = OutputParamContext(_localctx)
                    enterOuterAlt(_localctx, 1)
                    scoped {
                        this.state = 974
                        value(0)
                        this.state = 977
                        errorHandler.sync(this)

                        when (interpreter!!.adaptivePredict(_input!!, 132, context)) {
                            1 -> scoped {
                            this.state = 975
                            match(TILDE)
                            this.state = 976
                            typeEx()
                        }
                        }
                    }
                }As  ->  /*LL1AltBlock*/ {
                    _localctx = NecessaryParamContext(_localctx)
                    enterOuterAlt(_localctx, 2)
                    scoped {
                        this.state = 979
                        match(As)
                        this.state = 980
                        match(ID)
                    }
                }
                else -> throw NoViableAltException(this)
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class InverseDefGateCompoContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_inverseDefGateCompo.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()

        public fun ARROWQM(): TerminalNode? = getToken(Tokens.ARROWQM.id, 0)
        public fun ARROW(): TerminalNode? = getToken(Tokens.ARROW.id, 0)
        public fun QM(): TerminalNode? = getToken(Tokens.QM.id, 0)
        public fun As(): TerminalNode? = getToken(Tokens.As.id, 0)
        public fun ID(): TerminalNode? = getToken(Tokens.ID.id, 0)

        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterInverseDefGateCompo(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitInverseDefGateCompo(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitInverseDefGateCompo(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun inverseDefGateCompo(): InverseDefGateCompoContext {
        var _localctx = InverseDefGateCompoContext(context, state)
        enterRule(_localctx, 116, Rules.RULE_inverseDefGateCompo.id)

        try {
            this.state = 990
            errorHandler.sync(this)

            when (_input!!.LA(1)) {
                ARROW , ARROWQM  ->  /*LL1AltBlock*/ {
                    enterOuterAlt(_localctx, 1)
                    scoped {
                        this.state = 986
                        errorHandler.sync(this)

                        when (_input!!.LA(1)) {
                            ARROWQM  ->  /*LL1AltBlock*/ {
                                scoped {
                                    this.state = 983
                                    match(ARROWQM)
                                }
                            }ARROW  ->  /*LL1AltBlock*/ {
                                scoped {
                                    this.state = 984
                                    match(ARROW)
                                    this.state = 985
                                    match(QM)
                                }
                            }
                            else -> throw NoViableAltException(this)
                        }
                    }
                }As  ->  /*LL1AltBlock*/ {
                    enterOuterAlt(_localctx, 2)
                    scoped {
                        this.state = 988
                        match(As)
                        this.state = 989
                        match(ID)
                    }
                }
                else -> throw NoViableAltException(this)
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class LambdaContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_lambda.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()

        public fun LSQUARE(): TerminalNode? = getToken(Tokens.LSQUARE.id, 0)
        public fun RSQUARE(): TerminalNode? = getToken(Tokens.RSQUARE.id, 0)
        public fun findValue(): ValueContext? = getRuleContext(ValueContext::class, 0)
        public fun findParameter(): ParameterContext? = getRuleContext(ParameterContext::class, 0)

        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterLambda(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitLambda(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitLambda(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun lambda(): LambdaContext {
        var _localctx = LambdaContext(context, state)
        enterRule(_localctx, 118, Rules.RULE_lambda.id)
        var _la: Int

        try {
            enterOuterAlt(_localctx, 1)
            scoped {
                this.state = 992
                match(LSQUARE)
                this.state = 994
                errorHandler.sync(this)
                _la = _input!!.LA(1)

                if ((((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and -8959315521190219648L) != 0L) || ((((_la - 65)) and 0x3f.inv()) == 0 && ((1L shl (_la - 65)) and 233L) != 0L)) {
                    scoped {
                        this.state = 993
                        parameter()
                    }
                }
                this.state = 996
                match(RSQUARE)
                this.state = 997
                value(0)
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class TypeExContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_typeEx.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()

        public fun findTypeExFunc(): TypeExFuncContext? = getRuleContext(TypeExFuncContext::class, 0)
        public fun LPAREN(): TerminalNode? = getToken(Tokens.LPAREN.id, 0)
        public fun RPAREN(): TerminalNode? = getToken(Tokens.RPAREN.id, 0)
        public fun QM(): TerminalNode? = getToken(Tokens.QM.id, 0)
        public fun findTypeExSingle(): TypeExSingleContext? = getRuleContext(TypeExSingleContext::class, 0)

        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterTypeEx(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitTypeEx(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitTypeEx(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun typeEx(): TypeExContext {
        var _localctx = TypeExContext(context, state)
        enterRule(_localctx, 120, Rules.RULE_typeEx.id)

        try {
            this.state = 1012
            errorHandler.sync(this)

            when (_input!!.LA(1)) {
                LPAREN  ->  /*LL1AltBlock*/ {
                    enterOuterAlt(_localctx, 1)
                    scoped {
                        this.state = 1006
                        errorHandler.sync(this)

                        when (interpreter!!.adaptivePredict(_input!!, 138, context)) {
                            1 -> {
                                scoped {
                                    this.state = 999
                                    typeExFunc()
                                }
                            }2 -> {
                                scoped {
                                    this.state = 1000
                                    match(LPAREN)
                                    this.state = 1001
                                    typeExFunc()
                                    this.state = 1002
                                    match(RPAREN)
                                    this.state = 1004
                                    errorHandler.sync(this)

                                    when (interpreter!!.adaptivePredict(_input!!, 137, context)) {
                                        1 -> scoped {
                                        this.state = 1003
                                        match(QM)
                                    }
                                    }
                                }
                            }
                        }
                    }
                }INT , LONG , DOUBLE , FLOAT , BYTE , CHAR , STRING , BOOLEAN , UNIT , LBRACE , QUOTE , ID  ->  /*LL1AltBlock*/ {
                    enterOuterAlt(_localctx, 2)
                    scoped {
                        this.state = 1008
                        typeExSingle()
                        this.state = 1010
                        errorHandler.sync(this)

                        when (interpreter!!.adaptivePredict(_input!!, 139, context)) {
                            1 -> scoped {
                            this.state = 1009
                            match(QM)
                        }
                        }
                    }
                }
                else -> throw NoViableAltException(this)
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class TypeExSingleContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_typeExSingle.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()

        public fun findCommonClassIdentifier(): CommonClassIdentifierContext? = getRuleContext(CommonClassIdentifierContext::class, 0)
        public fun findPackage_(): Package_Context? = getRuleContext(Package_Context::class, 0)
        public fun DOT(): TerminalNode? = getToken(Tokens.DOT.id, 0)
        public fun LPAREN(): TerminalNode? = getToken(Tokens.LPAREN.id, 0)
        public fun RPAREN(): TerminalNode? = getToken(Tokens.RPAREN.id, 0)
        public fun findTypeArgEx(): List<TypeArgExContext> = getRuleContexts(TypeArgExContext::class)
        public fun findTypeArgEx(i: Int): TypeArgExContext? = getRuleContext(TypeArgExContext::class, i)
        public fun findPrimitiveType(): PrimitiveTypeContext? = getRuleContext(PrimitiveTypeContext::class, 0)

        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterTypeExSingle(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitTypeExSingle(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitTypeExSingle(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun typeExSingle(): TypeExSingleContext {
        var _localctx = TypeExSingleContext(context, state)
        enterRule(_localctx, 122, Rules.RULE_typeExSingle.id)
        var _la: Int

        try {
            this.state = 1031
            errorHandler.sync(this)

            when (_input!!.LA(1)) {
                LBRACE , QUOTE , ID  ->  /*LL1AltBlock*/ {
                    enterOuterAlt(_localctx, 1)
                    scoped {
                        this.state = 1017
                        errorHandler.sync(this)

                        when (interpreter!!.adaptivePredict(_input!!, 141, context)) {
                            1 -> scoped {
                            this.state = 1014
                            package_()
                            this.state = 1015
                            match(DOT)
                        }
                        }
                        this.state = 1019
                        commonClassIdentifier()
                        this.state = 1028
                        errorHandler.sync(this)

                        when (interpreter!!.adaptivePredict(_input!!, 143, context)) {
                            1 -> scoped {
                            this.state = 1020
                            match(LPAREN)
                            this.state = 1022 
                            errorHandler.sync(this)
                            _la = _input!!.LA(1)

                            do {
                                scoped {
                                    scoped {
                                        this.state = 1021
                                        typeArgEx()
                                    }
                                }
                                this.state = 1024 
                                errorHandler.sync(this)
                                _la = _input!!.LA(1)
                            } while (((((_la - 32)) and 0x3f.inv()) == 0 && ((1L shl (_la - 32)) and 70869713407L) != 0L))
                            this.state = 1026
                            match(RPAREN)
                        }
                        }
                    }
                }INT , LONG , DOUBLE , FLOAT , BYTE , CHAR , STRING , BOOLEAN , UNIT  ->  /*LL1AltBlock*/ {
                    enterOuterAlt(_localctx, 2)
                    scoped {
                        this.state = 1030
                        primitiveType()
                    }
                }
                else -> throw NoViableAltException(this)
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class TypeArgExContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_typeArgEx.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()

        public fun findTypeEx(): TypeExContext? = getRuleContext(TypeExContext::class, 0)
        public fun findTypeExCovariant(): TypeExCovariantContext? = getRuleContext(TypeExCovariantContext::class, 0)
        public fun findTypeExContravariant(): TypeExContravariantContext? = getRuleContext(TypeExContravariantContext::class, 0)
        public fun findTypeExWildcard(): TypeExWildcardContext? = getRuleContext(TypeExWildcardContext::class, 0)

        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterTypeArgEx(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitTypeArgEx(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitTypeArgEx(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun typeArgEx(): TypeArgExContext {
        var _localctx = TypeArgExContext(context, state)
        enterRule(_localctx, 124, Rules.RULE_typeArgEx.id)

        try {
            this.state = 1037
            errorHandler.sync(this)

            when (interpreter!!.adaptivePredict(_input!!, 145, context)) {
                1 -> {
                    enterOuterAlt(_localctx, 1)
                    scoped {
                        this.state = 1033
                        typeEx()
                    }
                }2 -> {
                    enterOuterAlt(_localctx, 2)
                    scoped {
                        this.state = 1034
                        typeExCovariant()
                    }
                }3 -> {
                    enterOuterAlt(_localctx, 3)
                    scoped {
                        this.state = 1035
                        typeExContravariant()
                    }
                }4 -> {
                    enterOuterAlt(_localctx, 4)
                    scoped {
                        this.state = 1036
                        typeExWildcard()
                    }
                }
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class PrimitiveTypeContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_primitiveType.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()

        public fun INT(): TerminalNode? = getToken(Tokens.INT.id, 0)
        public fun LONG(): TerminalNode? = getToken(Tokens.LONG.id, 0)
        public fun CHAR(): TerminalNode? = getToken(Tokens.CHAR.id, 0)
        public fun STRING(): TerminalNode? = getToken(Tokens.STRING.id, 0)
        public fun BYTE(): TerminalNode? = getToken(Tokens.BYTE.id, 0)
        public fun FLOAT(): TerminalNode? = getToken(Tokens.FLOAT.id, 0)
        public fun DOUBLE(): TerminalNode? = getToken(Tokens.DOUBLE.id, 0)
        public fun BOOLEAN(): TerminalNode? = getToken(Tokens.BOOLEAN.id, 0)
        public fun UNIT(): TerminalNode? = getToken(Tokens.UNIT.id, 0)

        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterPrimitiveType(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitPrimitiveType(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitPrimitiveType(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun primitiveType(): PrimitiveTypeContext {
        var _localctx = PrimitiveTypeContext(context, state)
        enterRule(_localctx, 126, Rules.RULE_primitiveType.id)
        var _la: Int

        try {
            enterOuterAlt(_localctx, 1)
            scoped {
                this.state = 1039
                _la = _input!!.LA(1)

                if (!((((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and 2194728288256L) != 0L))) {
                    errorHandler.recoverInline(this)
                }
                else {
                    if (_input!!.LA(1) == Tokens.EOF.id) {
                        isMatchedEOF = true
                    }

                    errorHandler.reportMatch(this)
                    consume()
                }
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class TypeExParamExContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_typeExParamEx.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()

        public fun findTypeEx(): TypeExContext? = getRuleContext(TypeExContext::class, 0)
        public fun ELLIPSIS(): TerminalNode? = getToken(Tokens.ELLIPSIS.id, 0)

        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterTypeExParamEx(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitTypeExParamEx(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitTypeExParamEx(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun typeExParamEx(): TypeExParamExContext {
        var _localctx = TypeExParamExContext(context, state)
        enterRule(_localctx, 128, Rules.RULE_typeExParamEx.id)
        var _la: Int

        try {
            enterOuterAlt(_localctx, 1)
            scoped {
                this.state = 1041
                typeEx()
                this.state = 1043
                errorHandler.sync(this)
                _la = _input!!.LA(1)

                if (_la == ELLIPSIS) {
                    scoped {
                        this.state = 1042
                        match(ELLIPSIS)
                    }
                }
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class TypeExFuncContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_typeExFunc.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()

        public fun LPAREN(): TerminalNode? = getToken(Tokens.LPAREN.id, 0)
        public fun RPAREN(): TerminalNode? = getToken(Tokens.RPAREN.id, 0)
        public fun ARROW(): TerminalNode? = getToken(Tokens.ARROW.id, 0)
        public fun findTypeEx(): TypeExContext? = getRuleContext(TypeExContext::class, 0)
        public fun findTypeExParamEx(): List<TypeExParamExContext> = getRuleContexts(TypeExParamExContext::class)
        public fun findTypeExParamEx(i: Int): TypeExParamExContext? = getRuleContext(TypeExParamExContext::class, i)

        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterTypeExFunc(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitTypeExFunc(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitTypeExFunc(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun typeExFunc(): TypeExFuncContext {
        var _localctx = TypeExFuncContext(context, state)
        enterRule(_localctx, 130, Rules.RULE_typeExFunc.id)
        var _la: Int

        try {
            enterOuterAlt(_localctx, 1)
            scoped {
                this.state = 1045
                match(LPAREN)
                this.state = 1049
                errorHandler.sync(this)
                _la = _input!!.LA(1)

                while (((((_la - 32)) and 0x3f.inv()) == 0 && ((1L shl (_la - 32)) and 70869189119L) != 0L)) {
                    scoped {
                        scoped {
                            this.state = 1046
                            typeExParamEx()
                        }
                    }
                    this.state = 1051
                    errorHandler.sync(this)
                    _la = _input!!.LA(1)
                }
                this.state = 1052
                match(RPAREN)
                this.state = 1053
                match(ARROW)
                this.state = 1054
                typeEx()
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class TypeExCovariantContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_typeExCovariant.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()

        public fun LSQUARE(): TerminalNode? = getToken(Tokens.LSQUARE.id, 0)
        public fun TILDE(): TerminalNode? = getToken(Tokens.TILDE.id, 0)
        public fun findTypeEx(): TypeExContext? = getRuleContext(TypeExContext::class, 0)
        public fun RSQUARE(): TerminalNode? = getToken(Tokens.RSQUARE.id, 0)

        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterTypeExCovariant(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitTypeExCovariant(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitTypeExCovariant(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun typeExCovariant(): TypeExCovariantContext {
        var _localctx = TypeExCovariantContext(context, state)
        enterRule(_localctx, 132, Rules.RULE_typeExCovariant.id)

        try {
            enterOuterAlt(_localctx, 1)
            scoped {
                this.state = 1056
                match(LSQUARE)
                this.state = 1057
                match(TILDE)
                this.state = 1058
                typeEx()
                this.state = 1059
                match(RSQUARE)
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class TypeExContravariantContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_typeExContravariant.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()

        public fun LSQUARE(): TerminalNode? = getToken(Tokens.LSQUARE.id, 0)
        public fun findTypeEx(): TypeExContext? = getRuleContext(TypeExContext::class, 0)
        public fun TILDE(): TerminalNode? = getToken(Tokens.TILDE.id, 0)
        public fun RSQUARE(): TerminalNode? = getToken(Tokens.RSQUARE.id, 0)

        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterTypeExContravariant(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitTypeExContravariant(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitTypeExContravariant(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun typeExContravariant(): TypeExContravariantContext {
        var _localctx = TypeExContravariantContext(context, state)
        enterRule(_localctx, 134, Rules.RULE_typeExContravariant.id)

        try {
            enterOuterAlt(_localctx, 1)
            scoped {
                this.state = 1061
                match(LSQUARE)
                this.state = 1062
                typeEx()
                this.state = 1063
                match(TILDE)
                this.state = 1064
                match(RSQUARE)
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class TypeExWildcardContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_typeExWildcard.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()

        public fun LSQUARE(): TerminalNode? = getToken(Tokens.LSQUARE.id, 0)
        public fun QM(): TerminalNode? = getToken(Tokens.QM.id, 0)
        public fun RSQUARE(): TerminalNode? = getToken(Tokens.RSQUARE.id, 0)

        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterTypeExWildcard(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitTypeExWildcard(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitTypeExWildcard(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun typeExWildcard(): TypeExWildcardContext {
        var _localctx = TypeExWildcardContext(context, state)
        enterRule(_localctx, 136, Rules.RULE_typeExWildcard.id)

        try {
            enterOuterAlt(_localctx, 1)
            scoped {
                this.state = 1066
                match(LSQUARE)
                this.state = 1067
                match(QM)
                this.state = 1068
                match(RSQUARE)
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class ForeignBodyContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_foreignBody.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()

        public fun LBRACE(): TerminalNode? = getToken(Tokens.LBRACE.id, 0)
        public fun RBRACE(): TerminalNode? = getToken(Tokens.RBRACE.id, 0)
        public fun findForeignElement(): List<ForeignElementContext> = getRuleContexts(ForeignElementContext::class)
        public fun findForeignElement(i: Int): ForeignElementContext? = getRuleContext(ForeignElementContext::class, i)
        public fun RawString(): TerminalNode? = getToken(Tokens.RawString.id, 0)

        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterForeignBody(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitForeignBody(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitForeignBody(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun foreignBody(): ForeignBodyContext {
        var _localctx = ForeignBodyContext(context, state)
        enterRule(_localctx, 138, Rules.RULE_foreignBody.id)
        var _la: Int

        try {
            this.state = 1079
            errorHandler.sync(this)

            when (_input!!.LA(1)) {
                LBRACE  ->  /*LL1AltBlock*/ {
                    enterOuterAlt(_localctx, 1)
                    scoped {
                        this.state = 1070
                        match(LBRACE)
                        this.state = 1074
                        errorHandler.sync(this)
                        _la = _input!!.LA(1)

                        while (_la == ID) {
                            scoped {
                                scoped {
                                    this.state = 1071
                                    foreignElement()
                                }
                            }
                            this.state = 1076
                            errorHandler.sync(this)
                            _la = _input!!.LA(1)
                        }
                        this.state = 1077
                        match(RBRACE)
                    }
                }RawString  ->  /*LL1AltBlock*/ {
                    enterOuterAlt(_localctx, 2)
                    scoped {
                        this.state = 1078
                        match(RawString)
                    }
                }
                else -> throw NoViableAltException(this)
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class ForeignElementContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_foreignElement.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()

        public fun findForeignPlatform(): ForeignPlatformContext? = getRuleContext(ForeignPlatformContext::class, 0)
        public fun RawString(): TerminalNode? = getToken(Tokens.RawString.id, 0)

        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterForeignElement(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitForeignElement(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitForeignElement(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun foreignElement(): ForeignElementContext {
        var _localctx = ForeignElementContext(context, state)
        enterRule(_localctx, 140, Rules.RULE_foreignElement.id)

        try {
            enterOuterAlt(_localctx, 1)
            scoped {
                this.state = 1081
                foreignPlatform()
                this.state = 1082
                match(RawString)
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class ForeignPlatformContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_foreignPlatform.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()

        public fun ID(): TerminalNode? = getToken(Tokens.ID.id, 0)

        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterForeignPlatform(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitForeignPlatform(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitForeignPlatform(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun foreignPlatform(): ForeignPlatformContext {
        var _localctx = ForeignPlatformContext(context, state)
        enterRule(_localctx, 142, Rules.RULE_foreignPlatform.id)

        try {
            enterOuterAlt(_localctx, 1)
            scoped {
                this.state = 1084
                match(ID)
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class TypeAliasContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_typeAlias.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()

        public fun TYPEALIAS(): TerminalNode? = getToken(Tokens.TYPEALIAS.id, 0)
        public fun findCommonClassIdentifier(): CommonClassIdentifierContext? = getRuleContext(CommonClassIdentifierContext::class, 0)
        public fun ASSGIN(): TerminalNode? = getToken(Tokens.ASSGIN.id, 0)
        public fun findTypeEx(): TypeExContext? = getRuleContext(TypeExContext::class, 0)
        public fun FOREIGN(): TerminalNode? = getToken(Tokens.FOREIGN.id, 0)
        public fun LPAREN(): TerminalNode? = getToken(Tokens.LPAREN.id, 0)
        public fun findTypeParam(): TypeParamContext? = getRuleContext(TypeParamContext::class, 0)
        public fun RPAREN(): TerminalNode? = getToken(Tokens.RPAREN.id, 0)
        public fun findForeignBody(): ForeignBodyContext? = getRuleContext(ForeignBodyContext::class, 0)
        public fun findForeignTypeExpectitive(): ForeignTypeExpectitiveContext? = getRuleContext(ForeignTypeExpectitiveContext::class, 0)

        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterTypeAlias(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitTypeAlias(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitTypeAlias(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun typeAlias(): TypeAliasContext {
        var _localctx = TypeAliasContext(context, state)
        enterRule(_localctx, 144, Rules.RULE_typeAlias.id)
        var _la: Int

        try {
            enterOuterAlt(_localctx, 1)
            scoped {
                this.state = 1086
                match(TYPEALIAS)
                this.state = 1087
                commonClassIdentifier()
                this.state = 1092
                errorHandler.sync(this)
                _la = _input!!.LA(1)

                if (_la == LPAREN) {
                    scoped {
                        this.state = 1088
                        match(LPAREN)
                        this.state = 1089
                        typeParam()
                        this.state = 1090
                        match(RPAREN)
                    }
                }
                this.state = 1103
                errorHandler.sync(this)

                when (_input!!.LA(1)) {
                    ASSGIN  ->  /*LL1AltBlock*/ {
                        scoped {
                            this.state = 1094
                            match(ASSGIN)
                            this.state = 1095
                            typeEx()
                        }
                    }FOREIGN  ->  /*LL1AltBlock*/ {
                        scoped {
                            this.state = 1096
                            match(FOREIGN)
                            this.state = 1098
                            errorHandler.sync(this)
                            _la = _input!!.LA(1)

                            if (_la == LBRACE || _la == RawString) {
                                scoped {
                                    this.state = 1097
                                    foreignBody()
                                }
                            }
                            this.state = 1101
                            errorHandler.sync(this)
                            _la = _input!!.LA(1)

                            if (_la == EXPECT) {
                                scoped {
                                    this.state = 1100
                                    foreignTypeExpectitive()
                                }
                            }
                        }
                    }
                    else -> throw NoViableAltException(this)
                }
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class ForeignTypeExpectitiveContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_foreignTypeExpectitive.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()

        public fun EXPECT(): TerminalNode? = getToken(Tokens.EXPECT.id, 0)
        public fun LBRACE(): TerminalNode? = getToken(Tokens.LBRACE.id, 0)
        public fun RBRACE(): TerminalNode? = getToken(Tokens.RBRACE.id, 0)
        public fun COLON(): List<TerminalNode> = getTokens(Tokens.COLON.id)
        public fun COLON(i: Int): TerminalNode = getToken(Tokens.COLON.id, i)!!
        public fun findDefInInterface(): List<DefInInterfaceContext> = getRuleContexts(DefInInterfaceContext::class)
        public fun findDefInInterface(i: Int): DefInInterfaceContext? = getRuleContext(DefInInterfaceContext::class, i)
        public fun IMPL(): List<TerminalNode> = getTokens(Tokens.IMPL.id)
        public fun IMPL(i: Int): TerminalNode = getToken(Tokens.IMPL.id, i)!!
        public fun findImpl(): List<ImplContext> = getRuleContexts(ImplContext::class)
        public fun findImpl(i: Int): ImplContext? = getRuleContext(ImplContext::class, i)

        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterForeignTypeExpectitive(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitForeignTypeExpectitive(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitForeignTypeExpectitive(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun foreignTypeExpectitive(): ForeignTypeExpectitiveContext {
        var _localctx = ForeignTypeExpectitiveContext(context, state)
        enterRule(_localctx, 146, Rules.RULE_foreignTypeExpectitive.id)
        var _la: Int

        try {
            enterOuterAlt(_localctx, 1)
            scoped {
                this.state = 1105
                match(EXPECT)
                this.state = 1106
                match(LBRACE)
                this.state = 1111
                errorHandler.sync(this)
                _la = _input!!.LA(1)

                while (_la == COLON) {
                    scoped {
                        scoped {
                            this.state = 1107
                            match(COLON)
                            this.state = 1108
                            defInInterface()
                        }
                    }
                    this.state = 1113
                    errorHandler.sync(this)
                    _la = _input!!.LA(1)
                }
                this.state = 1118
                errorHandler.sync(this)
                _la = _input!!.LA(1)

                while (_la == IMPL) {
                    scoped {
                        scoped {
                            this.state = 1114
                            match(IMPL)
                            this.state = 1115
                            impl()
                        }
                    }
                    this.state = 1120
                    errorHandler.sync(this)
                    _la = _input!!.LA(1)
                }
                this.state = 1121
                match(RBRACE)
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class AnnotationDefContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_annotationDef.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()

        public fun ANNOTATION(): TerminalNode? = getToken(Tokens.ANNOTATION.id, 0)
        public fun ID(): TerminalNode? = getToken(Tokens.ID.id, 0)
        public fun LPAREN(): TerminalNode? = getToken(Tokens.LPAREN.id, 0)
        public fun findParameter(): ParameterContext? = getRuleContext(ParameterContext::class, 0)
        public fun RPAREN(): TerminalNode? = getToken(Tokens.RPAREN.id, 0)

        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterAnnotationDef(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitAnnotationDef(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitAnnotationDef(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun annotationDef(): AnnotationDefContext {
        var _localctx = AnnotationDefContext(context, state)
        enterRule(_localctx, 148, Rules.RULE_annotationDef.id)

        try {
            enterOuterAlt(_localctx, 1)
            scoped {
                this.state = 1123
                match(ANNOTATION)
                this.state = 1124
                match(ID)
                scoped {
                    this.state = 1125
                    match(LPAREN)
                    this.state = 1126
                    parameter()
                    this.state = 1127
                    match(RPAREN)
                }
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class AnnotationContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_annotation.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()

        public fun ID(): TerminalNode? = getToken(Tokens.ID.id, 0)
        public fun findPackage_(): Package_Context? = getRuleContext(Package_Context::class, 0)
        public fun DOT(): TerminalNode? = getToken(Tokens.DOT.id, 0)
        public fun findArgValue(): ArgValueContext? = getRuleContext(ArgValueContext::class, 0)

        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterAnnotation(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitAnnotation(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitAnnotation(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun annotation(): AnnotationContext {
        var _localctx = AnnotationContext(context, state)
        enterRule(_localctx, 150, Rules.RULE_annotation.id)

        try {
            enterOuterAlt(_localctx, 1)
            scoped {
                this.state = 1132
                errorHandler.sync(this)

                when (interpreter!!.adaptivePredict(_input!!, 156, context)) {
                    1 -> scoped {
                    this.state = 1129
                    package_()
                    this.state = 1130
                    match(DOT)
                }
                }
                this.state = 1134
                match(ID)
                this.state = 1136
                errorHandler.sync(this)

                when (interpreter!!.adaptivePredict(_input!!, 157, context)) {
                    1 -> scoped {
                    this.state = 1135
                    argValue()
                }
                }
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    @Suppress("FunctionName")
    public open class AnnotationBlockContext : ParserRuleContext {
        override var ruleIndex: Int
            get() = Rules.RULE_annotationBlock.id
            set(@Suppress("UNUSED_PARAMETER") value) = throw RuntimeException()

        public fun LSQUARE(): TerminalNode? = getToken(Tokens.LSQUARE.id, 0)
        public fun RSQUARE(): TerminalNode? = getToken(Tokens.RSQUARE.id, 0)
        public fun findAnnotation(): List<AnnotationContext> = getRuleContexts(AnnotationContext::class)
        public fun findAnnotation(i: Int): AnnotationContext? = getRuleContext(AnnotationContext::class, i)

        public constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState) {
        }

        override fun enterRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.enterAnnotationBlock(this)
            }
        }

        override fun exitRule(listener: ParseTreeListener) {
            if (listener is FoldingListener) {
                listener.exitAnnotationBlock(this)
            }
        }

        override fun <T> accept(visitor: ParseTreeVisitor<out T>): T {
            if (visitor is FoldingVisitor) {
                return visitor.visitAnnotationBlock(this)
            } else {
                return visitor.visitChildren(this)!!
            }
        }
    }


    public fun annotationBlock(): AnnotationBlockContext {
        var _localctx = AnnotationBlockContext(context, state)
        enterRule(_localctx, 152, Rules.RULE_annotationBlock.id)
        var _la: Int

        try {
            enterOuterAlt(_localctx, 1)
            scoped {
                this.state = 1138
                match(LSQUARE)
                this.state = 1142
                errorHandler.sync(this)
                _la = _input!!.LA(1)

                while (_la == LBRACE || _la == ID) {
                    scoped {
                        scoped {
                            this.state = 1139
                            annotation()
                        }
                    }
                    this.state = 1144
                    errorHandler.sync(this)
                    _la = _input!!.LA(1)
                }
                this.state = 1145
                match(RSQUARE)
            }
        }
        catch (re: RecognitionException) {
            _localctx.exception = re
            errorHandler.reportError(this, re)
            errorHandler.recover(this, re)
        }
        finally {
            exitRule()
        }

        return _localctx
    }

    override fun sempred(_localctx: RuleContext?, ruleIndex: Int, predIndex: Int): Boolean {
        when (ruleIndex) {
            31 -> return value_sempred(_localctx as ValueContext?, predIndex)
        }

        return true
    }

    private fun value_sempred(_localctx: ValueContext?, predIndex: Int): Boolean {
        when (predIndex) {
            0 -> return (precpred(context!!, 18))
            1 -> return (precpred(context!!, 17))
            2 -> return (precpred(context!!, 16))
            3 -> return (precpred(context!!, 15))
            4 -> return (precpred(context!!, 14))
            5 -> return (precpred(context!!, 13))
            6 -> return (precpred(context!!, 12))
            7 -> return (precpred(context!!, 11))
            8 -> return (precpred(context!!, 9))
            9 -> return (precpred(context!!, 8))
            10 -> return (precpred(context!!, 7))
        }

        return true
    }
}